{"version":3,"file":"matrix.min.mjs","sources":["../../../../src/util/misc/matrix.ts"],"sourcesContent":["import { iMatrix } from '../../constants';\nimport type { XY } from '../../Point';\nimport { Point } from '../../Point';\nimport type { TDegree, TRadian, TMat2D } from '../../typedefs';\nimport { cos } from './cos';\nimport { degreesToRadians, radiansToDegrees } from './radiansDegreesConversion';\nimport { sin } from './sin';\n\nexport type TRotateMatrixArgs = {\n  angle?: TDegree;\n};\n\nexport type TTranslateMatrixArgs = {\n  translateX?: number;\n  translateY?: number;\n};\n\nexport type TScaleMatrixArgs = {\n  scaleX?: number;\n  scaleY?: number;\n  flipX?: boolean;\n  flipY?: boolean;\n  skewX?: TDegree;\n  skewY?: TDegree;\n};\n\nexport type TComposeMatrixArgs = TTranslateMatrixArgs &\n  TRotateMatrixArgs &\n  TScaleMatrixArgs;\n\nexport type TQrDecomposeOut = Required<\n  Omit<TComposeMatrixArgs, 'flipX' | 'flipY'>\n>;\n\nexport const isIdentityMatrix = (mat: TMat2D) =>\n  mat.every((value, index) => value === iMatrix[index]);\n\n/**\n * Apply transform t to point p\n * @deprecated use {@link Point#transform}\n * @param  {Point | XY} p The point to transform\n * @param  {Array} t The transform\n * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n * @return {Point} The transformed point\n */\nexport const transformPoint = (\n  p: XY,\n  t: TMat2D,\n  ignoreOffset?: boolean\n): Point => new Point(p).transform(t, ignoreOffset);\n\n/**\n * Invert transformation t\n * @param {Array} t The transform\n * @return {Array} The inverted transform\n */\nexport const invertTransform = (t: TMat2D): TMat2D => {\n  const a = 1 / (t[0] * t[3] - t[1] * t[2]),\n    r = [a * t[3], -a * t[1], -a * t[2], a * t[0], 0, 0] as TMat2D,\n    { x, y } = new Point(t[4], t[5]).transform(r, true);\n  r[4] = -x;\n  r[5] = -y;\n  return r;\n};\n\n/**\n * Multiply matrix A by matrix B to nest transformations\n * @param  {TMat2D} a First transformMatrix\n * @param  {TMat2D} b Second transformMatrix\n * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n * @return {TMat2D} The product of the two transform matrices\n */\nexport const multiplyTransformMatrices = (\n  a: TMat2D,\n  b: TMat2D,\n  is2x2?: boolean\n): TMat2D =>\n  [\n    a[0] * b[0] + a[2] * b[1],\n    a[1] * b[0] + a[3] * b[1],\n    a[0] * b[2] + a[2] * b[3],\n    a[1] * b[2] + a[3] * b[3],\n    is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\n    is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5],\n  ] as TMat2D;\n\n/**\n * Multiplies {@link matrices} such that a matrix defines the plane for the rest of the matrices **after** it\n *\n * `multiplyTransformMatrixArray([A, B, C, D])` is equivalent to `A(B(C(D)))`\n *\n * @param matrices an array of matrices\n * @param [is2x2] flag to multiply matrices as 2x2 matrices\n * @returns the multiplication product\n */\nexport const multiplyTransformMatrixArray = (\n  matrices: (TMat2D | undefined | null | false)[],\n  is2x2?: boolean\n) =>\n  matrices.reduceRight(\n    (product: TMat2D, curr) =>\n      curr ? multiplyTransformMatrices(curr, product, is2x2) : product,\n    iMatrix\n  );\n\nexport const calcPlaneRotation = ([a, b]: TMat2D) =>\n  Math.atan2(b, a) as TRadian;\n\n/**\n * Decomposes standard 2x3 matrix into transform components\n * @param  {TMat2D} a transformMatrix\n * @return {Object} Components of transform\n */\nexport const qrDecompose = (a: TMat2D): TQrDecomposeOut => {\n  const angle = calcPlaneRotation(a),\n    denom = Math.pow(a[0], 2) + Math.pow(a[1], 2),\n    scaleX = Math.sqrt(denom),\n    scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX,\n    skewX = Math.atan2(a[0] * a[2] + a[1] * a[3], denom);\n  return {\n    angle: radiansToDegrees(angle),\n    scaleX,\n    scaleY,\n    skewX: radiansToDegrees(skewX),\n    skewY: 0 as TDegree,\n    translateX: a[4] || 0,\n    translateY: a[5] || 0,\n  };\n};\n\n/**\n * Generate a translation matrix\n *\n * A translation matrix in the form of\n * [ 1 0 x ]\n * [ 0 1 y ]\n * [ 0 0 1 ]\n *\n * See @link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform#translate for more details\n *\n * @param {number} x translation on X axis\n * @param {number} [y] translation on Y axis\n * @returns {TMat2D} matrix\n */\nexport const createTranslateMatrix = (x: number, y = 0): TMat2D => [\n  1,\n  0,\n  0,\n  1,\n  x,\n  y,\n];\n\n/**\n * Generate a rotation matrix around around a point (x,y), defaulting to (0,0)\n *\n * A matrix in the form of\n * [cos(a) -sin(a) -x*cos(a)+y*sin(a)+x]\n * [sin(a)  cos(a) -x*sin(a)-y*cos(a)+y]\n * [0       0      1                 ]\n *\n *\n * @param {TDegree} angle rotation in degrees\n * @param {XY} [pivotPoint] pivot point to rotate around\n * @returns {TMat2D} matrix\n */\nexport function createRotateMatrix(\n  { angle = 0 }: TRotateMatrixArgs = {},\n  { x = 0, y = 0 }: Partial<XY> = {}\n): TMat2D {\n  const angleRadiant = degreesToRadians(angle),\n    cosValue = cos(angleRadiant),\n    sinValue = sin(angleRadiant);\n  return [\n    cosValue,\n    sinValue,\n    -sinValue,\n    cosValue,\n    x ? x - (cosValue * x - sinValue * y) : 0,\n    y ? y - (sinValue * x + cosValue * y) : 0,\n  ];\n}\n\n/**\n * Generate a scale matrix around the point (0,0)\n *\n * A matrix in the form of\n * [x 0 0]\n * [0 y 0]\n * [0 0 1]\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform#scale\n *\n * @param {number} x scale on X axis\n * @param {number} [y] scale on Y axis\n * @returns {TMat2D} matrix\n */\nexport const createScaleMatrix = (x: number, y: number = x): TMat2D => [\n  x,\n  0,\n  0,\n  y,\n  0,\n  0,\n];\n\nexport const angleToSkew = (angle: TDegree) =>\n  Math.tan(degreesToRadians(angle));\n\nexport const skewToAngle = (value: TRadian) =>\n  radiansToDegrees(Math.atan(value));\n\n/**\n * Generate a skew matrix for the X axis\n *\n * A matrix in the form of\n * [1 x 0]\n * [0 1 0]\n * [0 0 1]\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform#skewx\n *\n * @param {TDegree} skewValue translation on X axis\n * @returns {TMat2D} matrix\n */\nexport const createSkewXMatrix = (skewValue: TDegree): TMat2D => [\n  1,\n  0,\n  angleToSkew(skewValue),\n  1,\n  0,\n  0,\n];\n\n/**\n * Generate a skew matrix for the Y axis\n *\n * A matrix in the form of\n * [1 0 0]\n * [y 1 0]\n * [0 0 1]\n *\n * @link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform#skewy\n *\n * @param {TDegree} skewValue translation on Y axis\n * @returns {TMat2D} matrix\n */\nexport const createSkewYMatrix = (skewValue: TDegree): TMat2D => [\n  1,\n  angleToSkew(skewValue),\n  0,\n  1,\n  0,\n  0,\n];\n\n/**\n * Returns a transform matrix starting from an object of the same kind of\n * the one returned from qrDecompose, useful also if you want to calculate some\n * transformations from an object that is not enlived yet.\n * is called DimensionsTransformMatrix because those properties are the one that influence\n * the size of the resulting box of the object.\n * @param  {Object} options\n * @param  {Number} [options.scaleX]\n * @param  {Number} [options.scaleY]\n * @param  {Boolean} [options.flipX]\n * @param  {Boolean} [options.flipY]\n * @param  {Number} [options.skewX]\n * @param  {Number} [options.skewY]\n * @return {Number[]} transform matrix\n */\nexport const calcDimensionsMatrix = ({\n  scaleX = 1,\n  scaleY = 1,\n  flipX = false,\n  flipY = false,\n  skewX = 0 as TDegree,\n  skewY = 0 as TDegree,\n}: TScaleMatrixArgs) => {\n  return multiplyTransformMatrixArray(\n    [\n      createScaleMatrix(flipX ? -scaleX : scaleX, flipY ? -scaleY : scaleY),\n      skewX && createSkewXMatrix(skewX),\n      skewY && createSkewYMatrix(skewY),\n    ],\n    true\n  );\n};\n\n/**\n * Returns a transform matrix starting from an object of the same kind of\n * the one returned from qrDecompose, useful also if you want to calculate some\n * transformations from an object that is not enlived yet\n * @param  {Object} options\n * @param  {Number} [options.angle]\n * @param  {Number} [options.scaleX]\n * @param  {Number} [options.scaleY]\n * @param  {Boolean} [options.flipX]\n * @param  {Boolean} [options.flipY]\n * @param  {Number} [options.skewX]\n * @param  {Number} [options.skewY]\n * @param  {Number} [options.translateX]\n * @param  {Number} [options.translateY]\n * @return {Number[]} transform matrix\n */\nexport const composeMatrix = ({\n  translateX = 0,\n  translateY = 0,\n  angle = 0 as TDegree,\n  ...otherOptions\n}: TComposeMatrixArgs): TMat2D => {\n  return multiplyTransformMatrixArray([\n    createTranslateMatrix(translateX, translateY),\n    angle && createRotateMatrix({ angle }),\n    calcDimensionsMatrix(otherOptions),\n  ]);\n};\n"],"names":["isIdentityMatrix","mat","every","value","index","iMatrix","transformPoint","p","t","ignoreOffset","Point","transform","invertTransform","a","r","x","y","multiplyTransformMatrices","b","is2x2","multiplyTransformMatrixArray","matrices","reduceRight","product","curr","calcPlaneRotation","_ref","Math","atan2","qrDecompose","angle","denom","pow","scaleX","sqrt","scaleY","skewX","radiansToDegrees","skewY","translateX","translateY","createTranslateMatrix","arguments","length","undefined","createRotateMatrix","angleRadiant","degreesToRadians","cosValue","cos","sinValue","sin","createScaleMatrix","angleToSkew","tan","createSkewXMatrix","skewValue","createSkewYMatrix","calcDimensionsMatrix","_ref2","flipX","flipY","composeMatrix","_ref3","otherOptions","_objectWithoutProperties","_excluded"],"mappings":"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"}