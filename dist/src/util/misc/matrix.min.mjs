import{objectWithoutProperties as t}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{iMatrix as n}from"../../constants.min.mjs";import{Point as e}from"../../Point.min.mjs";import{cos as r}from"./cos.min.mjs";import{radiansToDegrees as a,degreesToRadians as o}from"./radiansDegreesConversion.min.mjs";import{sin as s}from"./sin.min.mjs";const l=["translateX","translateY","angle"],i=t=>t.every(((t,e)=>t===n[e])),m=(t,n,r)=>new e(t).transform(n,r),c=t=>{const n=1/(t[0]*t[3]-t[1]*t[2]),r=[n*t[3],-n*t[1],-n*t[2],n*t[0],0,0],{x:a,y:o}=new e(t[4],t[5]).transform(r,!0);return r[4]=-a,r[5]=-o,r},u=(t,n,e)=>[t[0]*n[0]+t[2]*n[1],t[1]*n[0]+t[3]*n[1],t[0]*n[2]+t[2]*n[3],t[1]*n[2]+t[3]*n[3],e?0:t[0]*n[4]+t[2]*n[5]+t[4],e?0:t[1]*n[4]+t[3]*n[5]+t[5]],p=(t,e)=>t.reduceRight(((t,n)=>n?u(n,t,e):t),n),f=t=>{let[n,e]=t;return Math.atan2(e,n)},g=t=>{const n=f(t),e=Math.pow(t[0],2)+Math.pow(t[1],2),r=Math.sqrt(e),o=(t[0]*t[3]-t[2]*t[1])/r,s=Math.atan2(t[0]*t[2]+t[1]*t[3],e);return{angle:a(n),scaleX:r,scaleY:o,skewX:a(s),skewY:0,translateX:t[4]||0,translateY:t[5]||0}},h=function(t){return[1,0,0,1,t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0]};function w(){let{angle:t=0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{x:n=0,y:e=0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const a=o(t),l=r(a),i=s(a);return[l,i,-i,l,n?n-(l*n-i*e):0,e?e-(i*n+l*e):0]}const X=function(t){return[t,0,0,arguments.length>1&&void 0!==arguments[1]?arguments[1]:t,0,0]},Y=t=>Math.tan(o(t)),j=t=>[1,0,Y(t),1,0,0],v=t=>[1,Y(t),0,1,0,0],d=t=>{let{scaleX:n=1,scaleY:e=1,flipX:r=!1,flipY:a=!1,skewX:o=0,skewY:s=0}=t;return p([X(r?-n:n,a?-e:e),o&&j(o),s&&v(s)],!0)},M=n=>{let{translateX:e=0,translateY:r=0,angle:a=0}=n,o=t(n,l);return p([h(e,r),a&&w({angle:a}),d(o)])};export{Y as angleToSkew,d as calcDimensionsMatrix,f as calcPlaneRotation,M as composeMatrix,w as createRotateMatrix,X as createScaleMatrix,j as createSkewXMatrix,v as createSkewYMatrix,h as createTranslateMatrix,c as invertTransform,i as isIdentityMatrix,u as multiplyTransformMatrices,p as multiplyTransformMatrixArray,g as qrDecompose,m as transformPoint};
//# sourceMappingURL=matrix.min.mjs.map
