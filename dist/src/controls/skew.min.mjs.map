{"version":3,"file":"skew.min.mjs","sources":["../../../src/controls/skew.ts"],"sourcesContent":["import type {\n  ControlCursorCallback,\n  TPointerEvent,\n  Transform,\n  TransformActionHandler,\n} from '../EventTypeDefs';\nimport { resolveOrigin } from '../util/misc/resolveOrigin';\nimport { Point } from '../Point';\nimport type { TAxis, TAxisKey } from '../typedefs';\nimport {\n  degreesToRadians,\n  radiansToDegrees,\n} from '../util/misc/radiansDegreesConversion';\nimport {\n  findCornerQuadrant,\n  getLocalPoint,\n  isLocked,\n  NOT_ALLOWED_CURSOR,\n} from './util';\nimport { wrapWithFireEvent } from './wrapWithFireEvent';\nimport { wrapWithFixedAnchor } from './wrapWithFixedAnchor';\nimport { CENTER } from '../constants';\n\nexport type SkewTransform = Transform & { skewingSide: -1 | 1 };\n\nconst AXIS_KEYS: Record<\n  TAxis,\n  {\n    counterAxis: TAxis;\n    scale: TAxisKey<'scale'>;\n    skew: TAxisKey<'skew'>;\n    lockSkewing: TAxisKey<'lockSkewing'>;\n    origin: TAxisKey<'origin'>;\n    flip: TAxisKey<'flip'>;\n  }\n> = {\n  x: {\n    counterAxis: 'y',\n    scale: 'scaleX',\n    skew: 'skewX',\n    lockSkewing: 'lockSkewingX',\n    origin: 'originX',\n    flip: 'flipX',\n  },\n  y: {\n    counterAxis: 'x',\n    scale: 'scaleY',\n    skew: 'skewY',\n    lockSkewing: 'lockSkewingY',\n    origin: 'originY',\n    flip: 'flipY',\n  },\n};\n\nconst skewMap = ['ns', 'nesw', 'ew', 'nwse'];\n\n/**\n * return the correct cursor style for the skew action\n * @param {Event} eventData the javascript event that is causing the scale\n * @param {Control} control the control that is interested in the action\n * @param {FabricObject} fabricObject the fabric object that is interested in the action\n * @return {String} a valid css string for the cursor\n */\nexport const skewCursorStyleHandler: ControlCursorCallback = (\n  eventData,\n  control,\n  fabricObject\n) => {\n  if (control.x !== 0 && isLocked(fabricObject, 'lockSkewingY')) {\n    return NOT_ALLOWED_CURSOR;\n  }\n  if (control.y !== 0 && isLocked(fabricObject, 'lockSkewingX')) {\n    return NOT_ALLOWED_CURSOR;\n  }\n  const n = findCornerQuadrant(fabricObject, control) % 4;\n  return `${skewMap[n]}-resize`;\n};\n\n/**\n * Since skewing is applied before scaling, calculations are done in a scaleless plane\n * @see https://github.com/fabricjs/fabric.js/pull/8380\n */\nfunction skewObject(\n  axis: TAxis,\n  { target, ex, ey, skewingSide, ...transform }: SkewTransform,\n  pointer: Point\n) {\n  const { skew: skewKey } = AXIS_KEYS[axis],\n    offset = pointer\n      .subtract(new Point(ex, ey))\n      .divide(new Point(target.scaleX, target.scaleY))[axis],\n    skewingBefore = target[skewKey],\n    skewingStart = transform[skewKey],\n    shearingStart = Math.tan(degreesToRadians(skewingStart)),\n    // let a, b be the size of target\n    // let a' be the value of a after applying skewing\n    // then:\n    // a' = a + b * skewA => skewA = (a' - a) / b\n    // the value b is tricky since skewY is applied before skewX\n    b =\n      axis === 'y'\n        ? target._getTransformedDimensions({\n            scaleX: 1,\n            scaleY: 1,\n            // since skewY is applied before skewX, b (=width) is not affected by skewX\n            skewX: 0,\n          }).x\n        : target._getTransformedDimensions({\n            scaleX: 1,\n            scaleY: 1,\n          }).y;\n\n  const shearing =\n    (2 * offset * skewingSide) /\n      // we max out fractions to safeguard from asymptotic behavior\n      Math.max(b, 1) +\n    // add starting state\n    shearingStart;\n\n  const skewing = radiansToDegrees(Math.atan(shearing));\n\n  target.set(skewKey, skewing);\n  const changed = skewingBefore !== target[skewKey];\n\n  if (changed && axis === 'y') {\n    // we don't want skewing to affect scaleX\n    // so we factor it by the inverse skewing diff to make it seem unchanged to the viewer\n    const { skewX, scaleX } = target,\n      dimBefore = target._getTransformedDimensions({ skewY: skewingBefore }),\n      dimAfter = target._getTransformedDimensions(),\n      compensationFactor = skewX !== 0 ? dimBefore.x / dimAfter.x : 1;\n    compensationFactor !== 1 &&\n      target.set('scaleX', compensationFactor * scaleX);\n  }\n\n  return changed;\n}\n\n/**\n * Wrapped Action handler for skewing on a given axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nfunction skewHandler(\n  axis: TAxis,\n  eventData: TPointerEvent,\n  transform: Transform,\n  x: number,\n  y: number\n) {\n  const { target } = transform,\n    {\n      counterAxis,\n      origin: originKey,\n      lockSkewing: lockSkewingKey,\n      skew: skewKey,\n      flip: flipKey,\n    } = AXIS_KEYS[axis];\n  if (isLocked(target, lockSkewingKey)) {\n    return false;\n  }\n\n  const { origin: counterOriginKey, flip: counterFlipKey } =\n      AXIS_KEYS[counterAxis],\n    counterOriginFactor =\n      resolveOrigin(transform[counterOriginKey]) *\n      (target[counterFlipKey] ? -1 : 1),\n    // if the counter origin is top/left (= -0.5) then we are skewing x/y values on the bottom/right side of target respectively.\n    // if the counter origin is bottom/right (= 0.5) then we are skewing x/y values on the top/left side of target respectively.\n    // skewing direction on the top/left side of target is OPPOSITE to the direction of the movement of the pointer,\n    // so we factor skewing direction by this value.\n    skewingSide = (-Math.sign(counterOriginFactor) *\n      (target[flipKey] ? -1 : 1)) as 1 | -1,\n    skewingDirection =\n      ((target[skewKey] === 0 &&\n        // in case skewing equals 0 we use the pointer offset from target center to determine the direction of skewing\n        getLocalPoint(transform, CENTER, CENTER, x, y)[axis] > 0) ||\n      // in case target has skewing we use that as the direction\n      target[skewKey] > 0\n        ? 1\n        : -1) * skewingSide,\n    // anchor to the opposite side of the skewing direction\n    // normalize value from [-1, 1] to origin value [0, 1]\n    origin = -skewingDirection * 0.5 + 0.5;\n\n  const finalHandler = wrapWithFireEvent<SkewTransform>(\n    'skewing',\n    wrapWithFixedAnchor((eventData, transform, x, y) =>\n      skewObject(axis, transform, new Point(x, y))\n    )\n  );\n\n  return finalHandler(\n    eventData,\n    {\n      ...transform,\n      [originKey]: origin,\n      skewingSide,\n    },\n    x,\n    y\n  );\n}\n\n/**\n * Wrapped Action handler for skewing on the X axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nexport const skewHandlerX: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y\n) => {\n  return skewHandler('x', eventData, transform, x, y);\n};\n\n/**\n * Wrapped Action handler for skewing on the Y axis, takes care of the\n * skew direction and determines the correct transform origin for the anchor point\n * @param {Event} eventData javascript event that is doing the transform\n * @param {Object} transform javascript object containing a series of information around the current transform\n * @param {number} x current mouse x position, canvas normalized\n * @param {number} y current mouse y position, canvas normalized\n * @return {Boolean} true if some change happened\n */\nexport const skewHandlerY: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y\n) => {\n  return skewHandler('y', eventData, transform, x, y);\n};\n"],"names":["AXIS_KEYS","x","counterAxis","scale","skew","lockSkewing","origin","flip","y","skewMap","skewCursorStyleHandler","eventData","control","fabricObject","isLocked","NOT_ALLOWED_CURSOR","n","findCornerQuadrant","concat","skewHandler","axis","transform","target","originKey","lockSkewingKey","skewKey","flipKey","counterOriginKey","counterFlipKey","counterOriginFactor","resolveOrigin","skewingSide","Math","sign","getLocalPoint","CENTER","finalHandler","wrapWithFireEvent","wrapWithFixedAnchor","_ref","pointer","ex","ey","_objectWithoutProperties","_excluded","offset","subtract","Point","divide","scaleX","scaleY","skewingBefore","skewingStart","shearingStart","tan","degreesToRadians","b","_getTransformedDimensions","skewX","shearing","max","skewing","radiansToDegrees","atan","set","changed","dimBefore","skewY","dimAfter","compensationFactor","skewObject","_objectSpread","skewHandlerX","skewHandlerY"],"mappings":"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"}