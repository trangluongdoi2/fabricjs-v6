{"version":3,"file":"LayoutStrategy.min.mjs","sources":["../../../../src/LayoutManager/LayoutStrategies/LayoutStrategy.ts"],"sourcesContent":["import { Point } from '../../Point';\nimport type { FabricObject } from '../../shapes/Object/FabricObject';\nimport { makeBoundingBoxFromPoints } from '../../util/misc/boundingBoxFromPoints';\nimport {\n  LAYOUT_TYPE_INITIALIZATION,\n  LAYOUT_TYPE_IMPERATIVE,\n} from '../constants';\nimport type {\n  InitializationLayoutContext,\n  LayoutStrategyResult,\n  StrictLayoutContext,\n} from '../types';\nimport { getObjectBounds } from './utils';\n\n/**\n * Exposes a main public method {@link calcLayoutResult} that is used by the `LayoutManager` to perform layout.\n * Returning `undefined` signals the `LayoutManager` to skip the layout.\n *\n * In charge of calculating the bounding box of the passed objects.\n */\nexport abstract class LayoutStrategy {\n  /**\n   * override by subclass for persistence (TS does not support `static abstract`)\n   */\n  static type = 'strategy';\n\n  /**\n   * Used by the `LayoutManager` to perform layout\n   * @returns layout result **OR** `undefined` to skip layout\n   */\n  public calcLayoutResult(\n    context: StrictLayoutContext,\n    objects: FabricObject[]\n  ): LayoutStrategyResult | undefined {\n    if (this.shouldPerformLayout(context)) {\n      return this.calcBoundingBox(objects, context);\n    }\n  }\n\n  shouldPerformLayout(context: StrictLayoutContext) {\n    return (\n      context.type === LAYOUT_TYPE_INITIALIZATION ||\n      context.type === LAYOUT_TYPE_IMPERATIVE ||\n      (!!context.prevStrategy && context.strategy !== context.prevStrategy)\n    );\n  }\n\n  shouldLayoutClipPath({ type, target: { clipPath } }: StrictLayoutContext) {\n    return (\n      type !== LAYOUT_TYPE_INITIALIZATION &&\n      clipPath &&\n      !clipPath.absolutePositioned\n    );\n  }\n\n  getInitialSize(\n    context: StrictLayoutContext & InitializationLayoutContext,\n    result: Pick<LayoutStrategyResult, 'center' | 'size'>\n  ) {\n    return result.size;\n  }\n\n  /**\n   * Override this method to customize layout.\n   */\n  calcBoundingBox(\n    objects: FabricObject[],\n    context: StrictLayoutContext\n  ): LayoutStrategyResult | undefined {\n    if (context.type === LAYOUT_TYPE_IMPERATIVE && context.overrides) {\n      return context.overrides;\n    }\n    if (objects.length === 0) {\n      return;\n    }\n    const { target } = context;\n    const { left, top, width, height } = makeBoundingBoxFromPoints(\n      objects\n        .map((object) => getObjectBounds(target, object))\n        .reduce<Point[]>((coords, curr) => coords.concat(curr), [])\n    );\n    const bboxSize = new Point(width, height);\n    const bboxLeftTop = new Point(left, top);\n    const bboxCenter = bboxLeftTop.add(bboxSize.scalarDivide(2));\n\n    if (context.type === LAYOUT_TYPE_INITIALIZATION) {\n      const actualSize = this.getInitialSize(context, {\n        size: bboxSize,\n        center: bboxCenter,\n      });\n      return {\n        // in `initialization` we do not account for target's transformation matrix\n        center: bboxCenter,\n        // TODO: investigate if this is still necessary\n        relativeCorrection: new Point(0, 0),\n        size: actualSize,\n      };\n    } else {\n      //  we send `relativeCenter` up to group's containing plane\n      const center = bboxCenter.transform(target.calcOwnMatrix());\n      return {\n        center,\n        size: bboxSize,\n      };\n    }\n  }\n}\n"],"names":["LayoutStrategy","calcLayoutResult","context","objects","this","shouldPerformLayout","calcBoundingBox","type","LAYOUT_TYPE_INITIALIZATION","LAYOUT_TYPE_IMPERATIVE","prevStrategy","strategy","shouldLayoutClipPath","_ref","target","clipPath","absolutePositioned","getInitialSize","result","size","overrides","length","left","top","width","height","makeBoundingBoxFromPoints","map","object","getObjectBounds","reduce","coords","curr","concat","bboxSize","Point","bboxCenter","add","scalarDivide","actualSize","center","relativeCorrection","transform","calcOwnMatrix","_defineProperty"],"mappings":"2WAoBO,MAAeA,EAUbC,gBAAAA,CACLC,EACAC,GAEA,GAAIC,KAAKC,oBAAoBH,GAC3B,OAAOE,KAAKE,gBAAgBH,EAASD,EAEzC,CAEAG,mBAAAA,CAAoBH,GAClB,OACEA,EAAQK,OAASC,GACjBN,EAAQK,OAASE,KACdP,EAAQQ,cAAgBR,EAAQS,WAAaT,EAAQQ,YAE5D,CAEAE,oBAAAA,CAAoBC,GAAsD,IAArDN,KAAEA,EAAMO,QAAQC,SAAEA,IAAiCF,EACtE,OACEN,IAASC,GACTO,IACCA,EAASC,kBAEd,CAEAC,cAAAA,CACEf,EACAgB,GAEA,OAAOA,EAAOC,IAChB,CAKAb,eAAAA,CACEH,EACAD,GAEA,GAAIA,EAAQK,OAASE,GAA0BP,EAAQkB,UACrD,OAAOlB,EAAQkB,UAEjB,GAAuB,IAAnBjB,EAAQkB,OACV,OAEF,MAAMP,OAAEA,GAAWZ,GACboB,KAAEA,EAAIC,IAAEA,EAAGC,MAAEA,EAAKC,OAAEA,GAAWC,EACnCvB,EACGwB,KAAKC,GAAWC,EAAgBf,EAAQc,KACxCE,QAAgB,CAACC,EAAQC,IAASD,EAAOE,OAAOD,IAAO,KAEtDE,EAAW,IAAIC,EAAMX,EAAOC,GAE5BW,EADc,IAAID,EAAMb,EAAMC,GACLc,IAAIH,EAASI,aAAa,IAEzD,GAAIpC,EAAQK,OAASC,EAA4B,CAC/C,MAAM+B,EAAanC,KAAKa,eAAef,EAAS,CAC9CiB,KAAMe,EACNM,OAAQJ,IAEV,MAAO,CAELI,OAAQJ,EAERK,mBAAoB,IAAIN,EAAM,EAAG,GACjChB,KAAMoB,EAEV,CAGE,MAAO,CACLC,OAFaJ,EAAWM,UAAU5B,EAAO6B,iBAGzCxB,KAAMe,EAGZ,EApFAU,EADoB5C,EAAc,OAIpB"}