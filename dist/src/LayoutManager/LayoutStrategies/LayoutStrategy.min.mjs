import{defineProperty as t}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as e}from"../../Point.min.mjs";import{makeBoundingBoxFromPoints as r}from"../../util/misc/boundingBoxFromPoints.min.mjs";import{LAYOUT_TYPE_INITIALIZATION as i,LAYOUT_TYPE_IMPERATIVE as o}from"../constants.min.mjs";import{getObjectBounds as n}from"./utils.min.mjs";class s{calcLayoutResult(t,e){if(this.shouldPerformLayout(t))return this.calcBoundingBox(e,t)}shouldPerformLayout(t){return t.type===i||t.type===o||!!t.prevStrategy&&t.strategy!==t.prevStrategy}shouldLayoutClipPath(t){let{type:e,target:{clipPath:r}}=t;return e!==i&&r&&!r.absolutePositioned}getInitialSize(t,e){return e.size}calcBoundingBox(t,s){if(s.type===o&&s.overrides)return s.overrides;if(0===t.length)return;const{target:a}=s,{left:l,top:m,width:u,height:c}=r(t.map((t=>n(a,t))).reduce(((t,e)=>t.concat(e)),[])),p=new e(u,c),d=new e(l,m).add(p.scalarDivide(2));if(s.type===i){const t=this.getInitialSize(s,{size:p,center:d});return{center:d,relativeCorrection:new e(0,0),size:t}}return{center:d.transform(a.calcOwnMatrix()),size:p}}}t(s,"type","strategy");export{s as LayoutStrategy};
//# sourceMappingURL=LayoutStrategy.min.mjs.map
