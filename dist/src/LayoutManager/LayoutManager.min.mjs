import{defineProperty as t,objectSpread2 as e,objectWithoutProperties as r}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as s}from"../Point.min.mjs";import{iMatrix as o,CENTER as i}from"../constants.min.mjs";import{invertTransform as a}from"../util/misc/matrix.min.mjs";import{resolveOrigin as n}from"../util/misc/resolveOrigin.min.mjs";import{FitContentLayout as u}from"./LayoutStrategies/FitContentLayout.min.mjs";import{LAYOUT_TYPE_OBJECT_MODIFIED as c,LAYOUT_TYPE_OBJECT_MODIFYING as y,LAYOUT_TYPE_INITIALIZATION as g,LAYOUT_TYPE_ADDED as l,LAYOUT_TYPE_REMOVED as p,LAYOUT_TYPE_IMPERATIVE as b}from"./constants.min.mjs";import{classRegistry as m}from"../ClassRegistry.min.mjs";const h=["strategy"],f=["target","strategy","bubbles","prevStrategy"],d="layoutManager";class j{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new u;t(this,"strategy",void 0),this.strategy=e,this._subscriptions=new Map}performLayout(t){const r=e(e({bubbles:!0,strategy:this.strategy},t),{},{prevStrategy:this._prevLayoutStrategy,stopPropagation(){this.bubbles=!1}});this.onBeforeLayout(r);const s=this.getLayoutResult(r);s&&this.commitLayout(r,s),this.onAfterLayout(r,s),this._prevLayoutStrategy=r.strategy}subscribe(t,r){const{target:s}=r;this.unsubscribe(t,r);const o=[t.on("modified",(t=>this.performLayout({trigger:"modified",e:t,type:c,target:s}))),...["moving","resizing","rotating","scaling","skewing","changed","modifyPoly"].map((r=>t.on(r,(o=>this.performLayout({trigger:r,e:e(e({},o),{},{target:t}),type:y,target:s})))))];this._subscriptions.set(t,o)}unsubscribe(t,e){(this._subscriptions.get(t)||[]).forEach((t=>t())),this._subscriptions.delete(t)}unsubscribeTargets(t){t.targets.forEach((e=>this.unsubscribe(e,t)))}subscribeTargets(t){t.targets.forEach((e=>this.subscribe(e,t)))}onBeforeLayout(t){const{target:s}=t,{canvas:o}=s;if(t.type===g||t.type===l?this.subscribeTargets(t):t.type===p&&this.unsubscribeTargets(t),s.fire("layout:before",{context:t}),o&&o.fire("object:layout:before",{target:s,context:t}),t.type===b&&t.deep){const o=r(t,h);s.forEachObject((t=>{var r;null===(r=t.layoutManager)||void 0===r||r.performLayout(e(e({},o),{},{bubbles:!1,target:t}))}))}}getLayoutResult(t){const{target:e}=t,r=t.strategy.calcLayoutResult(t,e.getObjects());if(!r)return;const i=t.type===g?new s:e.getRelativeCenterPoint(),{center:n,correction:u=new s,relativeCorrection:c=new s}=r,y=i.subtract(n).add(u).transform(t.type===g?o:a(e.calcOwnMatrix()),!0).add(c);return{result:r,prevCenter:i,nextCenter:n,offset:y}}commitLayout(t,e){const{target:r}=t,{result:{size:s},nextCenter:o}=e;var a,u;(r.set({width:s.x,height:s.y}),this.layoutObjects(t,e),t.type===g)?r.set({left:null!==(a=t.x)&&void 0!==a?a:o.x+s.x*n(r.originX),top:null!==(u=t.y)&&void 0!==u?u:o.y+s.y*n(r.originY)}):(r.setPositionByOrigin(o,i,i),r.setCoords(),r.set({dirty:!0}))}layoutObjects(t,e){const{target:r}=t;r.forEachObject((s=>{s.group===r&&this.layoutObject(t,e,s)})),t.strategy.shouldLayoutClipPath(t)&&this.layoutObject(t,e,r.clipPath)}layoutObject(t,e,r){let{offset:s}=e;r.set({left:r.left+s.x,top:r.top+s.y})}onAfterLayout(t,s){const{target:o,strategy:i,bubbles:a,prevStrategy:n}=t,u=r(t,f),{canvas:c}=o;o.fire("layout:after",{context:t,result:s}),c&&c.fire("object:layout:after",{context:t,result:s,target:o});const y=o.group;a&&null!=y&&y.layoutManager&&((u.path||(u.path=[])).push(o),y.layoutManager.performLayout(e(e({},u),{},{target:y})))}dispose(){this._subscriptions.forEach((t=>t.forEach((t=>t())))),this._subscriptions.clear()}toObject(){return{type:d,strategy:this.strategy.constructor.type}}toJSON(){return this.toObject()}}m.setClass(j,d);export{j as LayoutManager};
//# sourceMappingURL=LayoutManager.min.mjs.map
