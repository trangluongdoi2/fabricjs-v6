import{objectSpread2 as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Gradient as e}from"../gradient/Gradient.min.mjs";import{Group as i}from"../shapes/Group.min.mjs";import{FabricImage as s}from"../shapes/Image.min.mjs";import{classRegistry as r}from"../ClassRegistry.min.mjs";import{invertTransform as n,multiplyTransformMatrices as a,qrDecompose as o}from"../util/misc/matrix.min.mjs";import{removeTransformMatrixForSvgParsing as l}from"../util/transform_matrix_removal.min.mjs";import{Point as m}from"../Point.min.mjs";import{CENTER as c}from"../constants.min.mjs";import{getGradientDefs as p}from"./getGradientDefs.min.mjs";import{getCSSRules as h}from"./getCSSRules.min.mjs";import{getTagName as f}from"./getTagName.min.mjs";import{parseTransformAttribute as u}from"./parseTransformAttribute.min.mjs";const g=t=>r.getSVGClass(f(t).toLowerCase());class P{constructor(t,e,i,s,r){this.elements=t,this.options=e,this.reviver=i,this.regexUrl=/^url\(['"]?#([^'"]+)['"]?\)/g,this.doc=s,this.clipPaths=r,this.gradientDefs=p(s),this.cssRules=h(s)}parse(){return Promise.all(this.elements.map((t=>this.createObject(t))))}async createObject(t){const e=g(t);if(e){const i=await e.fromElement(t,this.options,this.cssRules);return this.resolveGradient(i,t,"fill"),this.resolveGradient(i,t,"stroke"),i instanceof s&&i._originalElement?l(i,i.parsePreserveAspectRatioAttribute()):l(i),await this.resolveClipPath(i,t),this.reviver&&this.reviver(t,i),i}return null}extractPropertyDefinition(t,e,i){const s=t[e],r=this.regexUrl;if(!r.test(s))return;r.lastIndex=0;const n=r.exec(s)[1];return r.lastIndex=0,i[n]}resolveGradient(i,s,r){const n=this.extractPropertyDefinition(i,r,this.gradientDefs);if(n){const a=s.getAttribute(r+"-opacity"),o=e.fromElement(n,i,t(t({},this.options),{},{opacity:a}));i.set(r,o)}}async resolveClipPath(t,e){const s=this.extractPropertyDefinition(t,"clipPath",this.clipPaths);if(s){const r=n(t.calcTransformMatrix()),p=s[0].parentElement;let h=e;for(;h.parentElement&&h.getAttribute("clip-path")!==t.clipPath;)h=h.parentElement;h.parentElement.appendChild(p);const f=u("".concat(h.getAttribute("transform")||""," ").concat(p.getAttribute("originalTransform")||""));p.setAttribute("transform","matrix(".concat(f.join(","),")"));const P=await Promise.all(s.map((t=>g(t).fromElement(t,this.options,this.cssRules).then((t=>(l(t),t.fillRule=t.clipRule,delete t.clipRule,t)))))),j=1===P.length?P[0]:new i(P),d=a(r,j.calcTransformMatrix());j.clipPath&&await this.resolveClipPath(j,h);const{scaleX:v,scaleY:x,angle:b,skewX:w,translateX:y,translateY:R}=o(d);j.set({flipX:!1,flipY:!1}),j.set({scaleX:v,scaleY:x,angle:b,skewX:w,skewY:0}),j.setPositionByOrigin(new m(y,R),c,c),t.clipPath=j}else delete t.clipPath}}export{P as ElementsParser};
//# sourceMappingURL=elements_parser.min.mjs.map
