import{ColorNameMap as t}from"./color_map.min.mjs";import{reRGBa as r,reHSLa as o,reHex as e}from"./constants.min.mjs";import{rgb2Hsl as s,hexify as c,greyAverage as n,fromAlphaToFloat as a,hue2rgb as u}from"./util.min.mjs";class i{constructor(t){if(t)if(t instanceof i)this.setSource([...t._source]);else if(Array.isArray(t)){const[r,o,e,s=1]=t;this.setSource([r,o,e,s])}else this.setSource(this._tryParsingColor(t));else this.setSource([0,0,0,1])}_tryParsingColor(r){return r in t&&(r=t[r]),"transparent"===r?[255,255,255,0]:i.sourceFromHex(r)||i.sourceFromRgb(r)||i.sourceFromHsl(r)||[0,0,0,1]}getSource(){return this._source}setSource(t){this._source=t}toRgb(){const[t,r,o]=this.getSource();return"rgb(".concat(t,",").concat(r,",").concat(o,")")}toRgba(){return"rgba(".concat(this.getSource().join(","),")")}toHsl(){const[t,r,o]=s(...this.getSource());return"hsl(".concat(t,",").concat(r,"%,").concat(o,"%)")}toHsla(){const[t,r,o,e]=s(...this.getSource());return"hsla(".concat(t,",").concat(r,"%,").concat(o,"%,").concat(e,")")}toHex(){return this.toHexa().slice(0,6)}toHexa(){const[t,r,o,e]=this.getSource();return"".concat(c(t)).concat(c(r)).concat(c(o)).concat(c(Math.round(255*e)))}getAlpha(){return this.getSource()[3]}setAlpha(t){return this._source[3]=t,this}toGrayscale(){return this.setSource(n(this.getSource())),this}toBlackWhite(t){const[r,,,o]=n(this.getSource()),e=r<(t||127)?0:255;return this.setSource([e,e,e,o]),this}overlayWith(t){t instanceof i||(t=new i(t));const r=this.getSource(),o=t.getSource(),[e,s,c]=r.map(((t,r)=>Math.round(.5*t+.5*o[r])));return this.setSource([e,s,c,r[3]]),this}static fromRgb(t){return i.fromRgba(t)}static fromRgba(t){return new i(i.sourceFromRgb(t))}static sourceFromRgb(t){const o=t.match(r());if(o){const[t,r,e]=o.slice(1,4).map((t=>{const r=parseFloat(t);return t.endsWith("%")?Math.round(2.55*r):r}));return[t,r,e,a(o[4])]}}static fromHsl(t){return i.fromHsla(t)}static fromHsla(t){return new i(i.sourceFromHsl(t))}static sourceFromHsl(t){const r=t.match(o());if(!r)return;const e=(parseFloat(r[1])%360+360)%360/360,s=parseFloat(r[2])/100,c=parseFloat(r[3])/100;let n,i,h;if(0===s)n=i=h=c;else{const t=c<=.5?c*(s+1):c+s-c*s,r=2*c-t;n=u(r,t,e+1/3),i=u(r,t,e),h=u(r,t,e-1/3)}return[Math.round(255*n),Math.round(255*i),Math.round(255*h),a(r[4])]}static fromHex(t){return new i(i.sourceFromHex(t))}static sourceFromHex(t){if(t.match(e())){const r=t.slice(t.indexOf("#")+1);let o;o=r.length<=4?r.split("").map((t=>t+t)):r.match(/.{2}/g);const[e,s,c,n=255]=o.map((t=>parseInt(t,16)));return[e,s,c,n/255]}}}export{i as Color};
//# sourceMappingURL=Color.min.mjs.map
