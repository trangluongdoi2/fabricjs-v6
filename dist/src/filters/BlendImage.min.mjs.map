{"version":3,"file":"BlendImage.min.mjs","sources":["../../../src/filters/BlendImage.ts"],"sourcesContent":["import { FabricImage } from '../shapes/Image';\nimport type { TClassProperties } from '../typedefs';\nimport { createCanvasElement } from '../util/misc/dom';\nimport { BaseFilter } from './BaseFilter';\nimport type {\n  T2DPipelineState,\n  TWebGLPipelineState,\n  TWebGLUniformLocationMap,\n} from './typedefs';\nimport type { WebGLFilterBackend } from './WebGLFilterBackend';\nimport { classRegistry } from '../ClassRegistry';\nimport { fragmentSource } from './shaders/blendImage';\n\nexport type TBlendImageMode = 'multiply' | 'mask';\n\nexport const blendImageDefaultValues: Partial<TClassProperties<BlendImage>> = {\n  mode: 'multiply',\n  alpha: 1,\n  vertexSource: `\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    uniform mat3 uTransformMatrix;\n    void main() {\n      vTexCoord = aPosition;\n      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n    `,\n};\n\n/**\n * Image Blend filter class\n * @example\n * const filter = new filters.BlendColor({\n *  color: '#000',\n *  mode: 'multiply'\n * });\n *\n * const filter = new BlendImage({\n *  image: fabricImageObject,\n *  mode: 'multiply',\n *  alpha: 0.5\n * });\n * object.filters.push(filter);\n * object.applyFilters();\n * canvas.renderAll();\n */\nexport class BlendImage extends BaseFilter {\n  /**\n   * Color to make the blend operation with. default to a reddish color since black or white\n   * gives always strong result.\n   **/\n  declare image: FabricImage;\n\n  declare mode: TBlendImageMode;\n\n  /**\n   * alpha value. represent the strength of the blend image operation.\n   * not implemented.\n   **/\n  declare alpha: number;\n\n  static type = 'BlendImage';\n\n  static defaults = blendImageDefaultValues;\n\n  getCacheKey() {\n    return `${this.type}_${this.mode}`;\n  }\n\n  getFragmentSource(): string {\n    return fragmentSource[this.mode];\n  }\n\n  applyToWebGL(options: TWebGLPipelineState) {\n    const gl = options.context,\n      texture = this.createTexture(options.filterBackend, this.image);\n    this.bindAdditionalTexture(gl, texture!, gl.TEXTURE1);\n    super.applyToWebGL(options);\n    this.unbindAdditionalTexture(gl, gl.TEXTURE1);\n  }\n\n  createTexture(backend: WebGLFilterBackend, image: FabricImage) {\n    return backend.getCachedTexture(image.cacheKey, image.getElement());\n  }\n\n  /**\n   * Calculate a transformMatrix to adapt the image to blend over\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */\n  calculateMatrix() {\n    const image = this.image,\n      { width, height } = image.getElement();\n    return [\n      1 / image.scaleX,\n      0,\n      0,\n      0,\n      1 / image.scaleY,\n      0,\n      -image.left / width,\n      -image.top / height,\n      1,\n    ];\n  }\n\n  /**\n   * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n   *\n   * @param {Object} options\n   * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n   */\n  applyTo2d({\n    imageData: { data, width, height },\n    filterBackend: { resources },\n  }: T2DPipelineState) {\n    const image = this.image;\n    if (!resources.blendImage) {\n      resources.blendImage = createCanvasElement();\n    }\n    const canvas1 = resources.blendImage;\n    const context = canvas1.getContext('2d')!;\n    if (canvas1.width !== width || canvas1.height !== height) {\n      canvas1.width = width;\n      canvas1.height = height;\n    } else {\n      context.clearRect(0, 0, width, height);\n    }\n    context.setTransform(\n      image.scaleX,\n      0,\n      0,\n      image.scaleY,\n      image.left,\n      image.top\n    );\n    context.drawImage(image.getElement(), 0, 0, width, height);\n    const blendData = context.getImageData(0, 0, width, height).data;\n    for (let i = 0; i < data.length; i += 4) {\n      const r = data[i];\n      const g = data[i + 1];\n      const b = data[i + 2];\n      const a = data[i + 3];\n\n      const tr = blendData[i];\n      const tg = blendData[i + 1];\n      const tb = blendData[i + 2];\n      const ta = blendData[i + 3];\n\n      switch (this.mode) {\n        case 'multiply':\n          data[i] = (r * tr) / 255;\n          data[i + 1] = (g * tg) / 255;\n          data[i + 2] = (b * tb) / 255;\n          data[i + 3] = (a * ta) / 255;\n          break;\n        case 'mask':\n          data[i + 3] = ta;\n          break;\n      }\n    }\n  }\n\n  /**\n   * Return WebGL uniform locations for this filter's shader.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n   * @param {WebGLShaderProgram} program This filter's compiled shader program.\n   */\n  getUniformLocations(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram\n  ): TWebGLUniformLocationMap {\n    return {\n      uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),\n      uImage: gl.getUniformLocation(program, 'uImage'),\n    };\n  }\n\n  /**\n   * Send data from this filter to its shader program's uniforms.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n   * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n   */\n  sendUniformData(\n    gl: WebGLRenderingContext,\n    uniformLocations: TWebGLUniformLocationMap\n  ) {\n    const matrix = this.calculateMatrix();\n    gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.\n    gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */\n  toObject() {\n    return {\n      type: this.type,\n      image: this.image && this.image.toObject(),\n      mode: this.mode,\n      alpha: this.alpha,\n    };\n  }\n\n  /**\n   * Create filter instance from an object representation\n   * @static\n   * @param {object} object Object to create an instance from\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] handle aborting image loading, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n   * @returns {Promise<BlendImage>}\n   */\n  static fromObject(\n    { type, image, ...filterOptions }: Record<string, any>,\n    options: { signal: AbortSignal }\n  ) {\n    return FabricImage.fromObject(image, options).then(\n      (enlivedImage) =>\n        new this({ ...filterOptions, image: enlivedImage }) as BaseFilter\n    );\n  }\n}\n\nclassRegistry.setClass(BlendImage);\n"],"names":["blendImageDefaultValues","mode","alpha","vertexSource","BlendImage","BaseFilter","getCacheKey","concat","this","type","getFragmentSource","fragmentSource","applyToWebGL","options","gl","context","texture","createTexture","filterBackend","image","bindAdditionalTexture","TEXTURE1","super","unbindAdditionalTexture","backend","getCachedTexture","cacheKey","getElement","calculateMatrix","width","height","scaleX","scaleY","left","top","applyTo2d","_ref","imageData","data","resources","blendImage","createCanvasElement","canvas1","getContext","clearRect","setTransform","drawImage","blendData","getImageData","i","length","r","g","b","a","tr","tg","tb","ta","getUniformLocations","program","uTransformMatrix","getUniformLocation","uImage","sendUniformData","uniformLocations","matrix","uniform1i","uniformMatrix3fv","toObject","fromObject","_ref2","filterOptions","_objectWithoutProperties","_excluded","FabricImage","then","enlivedImage","_objectSpread","_defineProperty","classRegistry","setClass"],"mappings":"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"}