import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{BaseFilter as e}from"./BaseFilter.min.mjs";import{isWebGLPipelineState as a}from"./utils.min.mjs";import{classRegistry as s}from"../ClassRegistry.min.mjs";import{createCanvasElement as i}from"../util/misc/dom.min.mjs";const o={resizeType:"hermite",scaleX:1,scaleY:1,lanczosLobes:3,fragmentSourceTOP:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n  "};class r extends e{getUniformLocations(t,e){return{uDelta:t.getUniformLocation(e,"uDelta"),uTaps:t.getUniformLocation(e,"uTaps")}}sendUniformData(t,e){t.uniform2fv(e.uDelta,this.horizontal?[1/this.width,0]:[0,1/this.height]),t.uniform1fv(e.uTaps,this.taps)}getFilterWindow(){const t=this.tempScale;return Math.ceil(this.lanczosLobes/t)}getCacheKey(){const t=this.getFilterWindow();return"".concat(this.type,"_").concat(t)}getFragmentSource(){const t=this.getFilterWindow();return this.generateShader(t)}getTaps(){const t=this.lanczosCreate(this.lanczosLobes),e=this.tempScale,a=this.getFilterWindow(),s=new Array(a);for(let i=1;i<=a;i++)s[i-1]=t(i*e);return s}generateShader(t){const e=new Array(t);for(let a=1;a<=t;a++)e[a-1]="".concat(a,".0 * uDelta");return"\n      ".concat(this.fragmentSourceTOP,"\n      uniform float uTaps[").concat(t,"];\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        float sum = 1.0;\n        ").concat(e.map(((t,e)=>"\n              color += texture2D(uTexture, vTexCoord + ".concat(t,") * uTaps[").concat(e,"] + texture2D(uTexture, vTexCoord - ").concat(t,") * uTaps[").concat(e,"];\n              sum += 2.0 * uTaps[").concat(e,"];\n            "))).join("\n"),"\n        gl_FragColor = color / sum;\n      }\n    ")}applyToForWebgl(t){t.passes++,this.width=t.sourceWidth,this.horizontal=!0,this.dW=Math.round(this.width*this.scaleX),this.dH=t.sourceHeight,this.tempScale=this.dW/this.width,this.taps=this.getTaps(),t.destinationWidth=this.dW,super.applyTo(t),t.sourceWidth=t.destinationWidth,this.height=t.sourceHeight,this.horizontal=!1,this.dH=Math.round(this.height*this.scaleY),this.tempScale=this.dH/this.height,this.taps=this.getTaps(),t.destinationHeight=this.dH,super.applyTo(t),t.sourceHeight=t.destinationHeight}applyTo(t){a(t)?this.applyToForWebgl(t):this.applyTo2d(t)}isNeutralState(){return 1===this.scaleX&&1===this.scaleY}lanczosCreate(t){return e=>{if(e>=t||e<=-t)return 0;if(e<1.1920929e-7&&e>-1.1920929e-7)return 1;const a=(e*=Math.PI)/t;return Math.sin(e)/e*Math.sin(a)/a}}applyTo2d(t){const e=t.imageData,a=this.scaleX,s=this.scaleY;this.rcpScaleX=1/a,this.rcpScaleY=1/s;const i=e.width,o=e.height,r=Math.round(i*a),h=Math.round(o*s);let n;n="sliceHack"===this.resizeType?this.sliceByTwo(t,i,o,r,h):"hermite"===this.resizeType?this.hermiteFastResize(t,i,o,r,h):"bilinear"===this.resizeType?this.bilinearFiltering(t,i,o,r,h):"lanczos"===this.resizeType?this.lanczosResize(t,i,o,r,h):new ImageData(r,h),t.imageData=n}sliceByTwo(t,e,a,s,o){const r=t.imageData,h=.5;let n=!1,c=!1,l=e*h,u=a*h;const p=t.filterBackend.resources;let m=0,f=0;const g=e;let d=0;p.sliceByTwo||(p.sliceByTwo=i());const T=p.sliceByTwo;(T.width<1.5*e||T.height<a)&&(T.width=1.5*e,T.height=a);const y=T.getContext("2d");for(y.clearRect(0,0,1.5*e,a),y.putImageData(r,0,0),s=Math.floor(s),o=Math.floor(o);!n||!c;)e=l,a=u,s<Math.floor(l*h)?l=Math.floor(l*h):(l=s,n=!0),o<Math.floor(u*h)?u=Math.floor(u*h):(u=o,c=!0),y.drawImage(T,m,f,e,a,g,d,l,u),m=g,f=d,d+=u;return y.getImageData(m,f,s,o)}lanczosResize(t,e,a,s,i){const o=t.imageData.data,r=t.ctx.createImageData(s,i),h=r.data,n=this.lanczosCreate(this.lanczosLobes),c=this.rcpScaleX,l=this.rcpScaleY,u=2/this.rcpScaleX,p=2/this.rcpScaleY,m=Math.ceil(c*this.lanczosLobes/2),f=Math.ceil(l*this.lanczosLobes/2),g={},d={x:0,y:0},T={x:0,y:0};return function t(y){let M,z,x,w,D,S,b,F,W,v,C;for(d.x=(y+.5)*c,T.x=Math.floor(d.x),M=0;M<i;M++){for(d.y=(M+.5)*l,T.y=Math.floor(d.y),D=0,S=0,b=0,F=0,W=0,z=T.x-m;z<=T.x+m;z++)if(!(z<0||z>=e)){v=Math.floor(1e3*Math.abs(z-d.x)),g[v]||(g[v]={});for(let t=T.y-f;t<=T.y+f;t++)t<0||t>=a||(C=Math.floor(1e3*Math.abs(t-d.y)),g[v][C]||(g[v][C]=n(Math.sqrt(Math.pow(v*u,2)+Math.pow(C*p,2))/1e3)),x=g[v][C],x>0&&(w=4*(t*e+z),D+=x,S+=x*o[w],b+=x*o[w+1],F+=x*o[w+2],W+=x*o[w+3]))}w=4*(M*s+y),h[w]=S/D,h[w+1]=b/D,h[w+2]=F/D,h[w+3]=W/D}return++y<s?t(y):r}(0)}bilinearFiltering(t,e,a,s,i){let o,r,h,n,c,l,u,p,m,f,g,d,T,y=0;const M=this.rcpScaleX,z=this.rcpScaleY,x=4*(e-1),w=t.imageData.data,D=t.ctx.createImageData(s,i),S=D.data;for(u=0;u<i;u++)for(p=0;p<s;p++)for(c=Math.floor(M*p),l=Math.floor(z*u),m=M*p-c,f=z*u-l,T=4*(l*e+c),g=0;g<4;g++)o=w[T+g],r=w[T+4+g],h=w[T+x+g],n=w[T+x+4+g],d=o*(1-m)*(1-f)+r*m*(1-f)+h*f*(1-m)+n*m*f,S[y++]=d;return D}hermiteFastResize(t,e,a,s,i){const o=this.rcpScaleX,r=this.rcpScaleY,h=Math.ceil(o/2),n=Math.ceil(r/2),c=t.imageData.data,l=t.ctx.createImageData(s,i),u=l.data;for(let t=0;t<i;t++)for(let a=0;a<s;a++){const i=4*(a+t*s);let l=0,p=0,m=0,f=0,g=0,d=0,T=0;const y=(t+.5)*r;for(let s=Math.floor(t*r);s<(t+1)*r;s++){const t=Math.abs(y-(s+.5))/n,i=(a+.5)*o,r=t*t;for(let t=Math.floor(a*o);t<(a+1)*o;t++){let a=Math.abs(i-(t+.5))/h;const o=Math.sqrt(r+a*a);o>1&&o<-1||(l=2*o*o*o-3*o*o+1,l>0&&(a=4*(t+s*e),T+=l*c[a+3],m+=l,c[a+3]<255&&(l=l*c[a+3]/250),f+=l*c[a],g+=l*c[a+1],d+=l*c[a+2],p+=l))}}u[i]=f/p,u[i+1]=g/p,u[i+2]=d/p,u[i+3]=T/m}return l}toObject(){return{type:this.type,scaleX:this.scaleX,scaleY:this.scaleY,resizeType:this.resizeType,lanczosLobes:this.lanczosLobes}}}t(r,"type","Resize"),t(r,"defaults",o),s.setClass(r);export{r as Resize,o as resizeDefaultValues};
//# sourceMappingURL=Resize.min.mjs.map
