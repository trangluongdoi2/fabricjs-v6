import{defineProperty as e,objectWithoutProperties as t,objectSpread2 as r}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{getEnv as i}from"../env/index.min.mjs";import{createCanvasElement as a}from"../util/misc/dom.min.mjs";import{isWebGLPipelineState as o}from"./utils.min.mjs";import{vertexSource as n,identityFragmentShader as s,highPsourceCode as c}from"./shaders/baseFilter.min.mjs";import{FabricError as u}from"../util/internals/console.min.mjs";const h=["type"],m=["type"];class p{get type(){return this.constructor.type}constructor(){let r=t(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},h);e(this,"vertexSource",n),Object.assign(this,this.constructor.defaults,r)}getFragmentSource(){return s}createProgram(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getFragmentSource(),r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.vertexSource;const{WebGLProbe:{GLPrecision:a="highp"}}=i();"highp"!==a&&(t=t.replace(new RegExp(c,"g"),c.replace("highp",a)));const o=e.createShader(e.VERTEX_SHADER),n=e.createShader(e.FRAGMENT_SHADER),s=e.createProgram();if(!o||!n||!s)throw new u("Vertex, fragment shader or program creation error");if(e.shaderSource(o,r),e.compileShader(o),!e.getShaderParameter(o,e.COMPILE_STATUS))throw new u("Vertex shader compile error for ".concat(this.type,": ").concat(e.getShaderInfoLog(o)));if(e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw new u("Fragment shader compile error for ".concat(this.type,": ").concat(e.getShaderInfoLog(n)));if(e.attachShader(s,o),e.attachShader(s,n),e.linkProgram(s),!e.getProgramParameter(s,e.LINK_STATUS))throw new u('Shader link error for "'.concat(this.type,'" ').concat(e.getProgramInfoLog(s)));const h=this.getUniformLocations(e,s)||{};return h.uStepW=e.getUniformLocation(s,"uStepW"),h.uStepH=e.getUniformLocation(s,"uStepH"),{program:s,attributeLocations:this.getAttributeLocations(e,s),uniformLocations:h}}getAttributeLocations(e,t){return{aPosition:e.getAttribLocation(t,"aPosition")}}getUniformLocations(e,t){return{}}sendAttributeData(e,t,r){const i=t.aPosition,a=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,a),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW)}_setupFrameBuffer(e){const t=e.context;if(e.passes>1){const r=e.destinationWidth,i=e.destinationHeight;e.sourceWidth===r&&e.sourceHeight===i||(t.deleteTexture(e.targetTexture),e.targetTexture=e.filterBackend.createTexture(t,r,i)),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e.targetTexture,0)}else t.bindFramebuffer(t.FRAMEBUFFER,null),t.finish()}_swapTextures(e){e.passes--,e.pass++;const t=e.targetTexture;e.targetTexture=e.sourceTexture,e.sourceTexture=t}isNeutralState(e){const t=this.mainParameter,r=this.constructor.defaults[t];if(t){const e=this[t];return Array.isArray(r)&&Array.isArray(e)?r.every(((t,r)=>t===e[r])):r===e}return!1}applyTo(e){o(e)?(this._setupFrameBuffer(e),this.applyToWebGL(e),this._swapTextures(e)):this.applyTo2d(e)}applyTo2d(e){}getCacheKey(){return this.type}retrieveShader(e){const t=this.getCacheKey();return e.programCache[t]||(e.programCache[t]=this.createProgram(e.context)),e.programCache[t]}applyToWebGL(e){const t=e.context,r=this.retrieveShader(e);0===e.pass&&e.originalTexture?t.bindTexture(t.TEXTURE_2D,e.originalTexture):t.bindTexture(t.TEXTURE_2D,e.sourceTexture),t.useProgram(r.program),this.sendAttributeData(t,r.attributeLocations,e.aPosition),t.uniform1f(r.uniformLocations.uStepW,1/e.sourceWidth),t.uniform1f(r.uniformLocations.uStepH,1/e.sourceHeight),this.sendUniformData(t,r.uniformLocations),t.viewport(0,0,e.destinationWidth,e.destinationHeight),t.drawArrays(t.TRIANGLE_STRIP,0,4)}bindAdditionalTexture(e,t,r){e.activeTexture(r),e.bindTexture(e.TEXTURE_2D,t),e.activeTexture(e.TEXTURE0)}unbindAdditionalTexture(e,t){e.activeTexture(t),e.bindTexture(e.TEXTURE_2D,null),e.activeTexture(e.TEXTURE0)}getMainParameter(){return this.mainParameter?this[this.mainParameter]:void 0}setMainParameter(e){this.mainParameter&&(this[this.mainParameter]=e)}sendUniformData(e,t){}createHelpLayer(e){if(!e.helpLayer){const t=a();t.width=e.sourceWidth,t.height=e.sourceHeight,e.helpLayer=t}}toObject(){const e=this.mainParameter;return r({type:this.type},e?{[e]:this[e]}:{})}toJSON(){return this.toObject()}static async fromObject(e,r){return new this(t(e,m))}}e(p,"type","BaseFilter");export{p as BaseFilter};
//# sourceMappingURL=BaseFilter.min.mjs.map
