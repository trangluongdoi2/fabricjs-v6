import{defineProperty as e,objectWithoutProperties as t,objectSpread2 as a}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{FabricImage as i}from"../shapes/Image.min.mjs";import{createCanvasElement as r}from"../util/misc/dom.min.mjs";import{BaseFilter as o}from"./BaseFilter.min.mjs";import{classRegistry as n}from"../ClassRegistry.min.mjs";import{fragmentSource as s}from"./shaders/blendImage.min.mjs";const m=["type","image"],c={mode:"multiply",alpha:1,vertexSource:"\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    uniform mat3 uTransformMatrix;\n    void main() {\n      vTexCoord = aPosition;\n      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n    "};class l extends o{getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return s[this.mode]}applyToWebGL(e){const t=e.context,a=this.createTexture(e.filterBackend,this.image);this.bindAdditionalTexture(t,a,t.TEXTURE1),super.applyToWebGL(e),this.unbindAdditionalTexture(t,t.TEXTURE1)}createTexture(e,t){return e.getCachedTexture(t.cacheKey,t.getElement())}calculateMatrix(){const e=this.image,{width:t,height:a}=e.getElement();return[1/e.scaleX,0,0,0,1/e.scaleY,0,-e.left/t,-e.top/a,1]}applyTo2d(e){let{imageData:{data:t,width:a,height:i},filterBackend:{resources:o}}=e;const n=this.image;o.blendImage||(o.blendImage=r());const s=o.blendImage,m=s.getContext("2d");s.width!==a||s.height!==i?(s.width=a,s.height=i):m.clearRect(0,0,a,i),m.setTransform(n.scaleX,0,0,n.scaleY,n.left,n.top),m.drawImage(n.getElement(),0,0,a,i);const c=m.getImageData(0,0,a,i).data;for(let e=0;e<t.length;e+=4){const a=t[e],i=t[e+1],r=t[e+2],o=t[e+3],n=c[e],s=c[e+1],m=c[e+2],l=c[e+3];switch(this.mode){case"multiply":t[e]=a*n/255,t[e+1]=i*s/255,t[e+2]=r*m/255,t[e+3]=o*l/255;break;case"mask":t[e+3]=l}}}getUniformLocations(e,t){return{uTransformMatrix:e.getUniformLocation(t,"uTransformMatrix"),uImage:e.getUniformLocation(t,"uImage")}}sendUniformData(e,t){const a=this.calculateMatrix();e.uniform1i(t.uImage,1),e.uniformMatrix3fv(t.uTransformMatrix,!1,a)}toObject(){return{type:this.type,image:this.image&&this.image.toObject(),mode:this.mode,alpha:this.alpha}}static fromObject(e,r){let{type:o,image:n}=e,s=t(e,m);return i.fromObject(n,r).then((e=>new this(a(a({},s),{},{image:e}))))}}e(l,"type","BlendImage"),e(l,"defaults",c),n.setClass(l);export{l as BlendImage,c as blendImageDefaultValues};
//# sourceMappingURL=BlendImage.min.mjs.map
