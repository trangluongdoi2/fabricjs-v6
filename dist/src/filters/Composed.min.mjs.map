{"version":3,"file":"Composed.min.mjs","sources":["../../../src/filters/Composed.ts"],"sourcesContent":["import { BaseFilter } from './BaseFilter';\nimport type { T2DPipelineState, TWebGLPipelineState } from './typedefs';\nimport { isWebGLPipelineState } from './utils';\nimport { classRegistry } from '../ClassRegistry';\n\n/**\n * A container class that knows how to apply a sequence of filters to an input image.\n */\nexport class Composed extends BaseFilter {\n  /**\n   * A non sparse array of filters to apply\n   */\n  declare subFilters: BaseFilter[];\n\n  static type = 'Composed';\n\n  constructor({\n    subFilters = [],\n    ...options\n  }: { subFilters?: BaseFilter[] } & Record<string, any> = {}) {\n    super(options);\n    this.subFilters = subFilters;\n  }\n\n  /**\n   * Apply this container's filters to the input image provided.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be applied.\n   */\n  applyTo(options: TWebGLPipelineState | T2DPipelineState) {\n    if (isWebGLPipelineState(options)) {\n      options.passes += this.subFilters.length - 1;\n    }\n    this.subFilters.forEach((filter) => {\n      filter.applyTo(options);\n    });\n  }\n\n  /**\n   * Serialize this filter into JSON.\n   *\n   * @returns {Object} A JSON representation of this filter.\n   */\n  toObject() {\n    return {\n      ...super.toObject(),\n      subFilters: this.subFilters.map((filter) => filter.toObject()),\n    };\n  }\n\n  isNeutralState() {\n    return !this.subFilters.some((filter) => !filter.isNeutralState());\n  }\n\n  /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   * @static\n   * @param {oject} object Object to create an instance from\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] handle aborting `BlendImage` filter loading, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n   * @returns {Promise<Composed>}\n   */\n  static fromObject(\n    object: Record<string, any>,\n    options: { signal: AbortSignal }\n  ) {\n    return Promise.all(\n      ((object.subFilters || []) as BaseFilter[]).map((filter) =>\n        classRegistry\n          .getClass<typeof BaseFilter>(filter.type)\n          .fromObject(filter, options)\n      )\n    ).then(\n      (enlivedFilters) => new this({ subFilters: enlivedFilters }) as BaseFilter\n    );\n  }\n}\n\nclassRegistry.setClass(Composed);\n"],"names":["Composed","BaseFilter","constructor","_ref","arguments","length","undefined","subFilters","super","_objectWithoutProperties","_excluded","this","applyTo","options","isWebGLPipelineState","passes","forEach","filter","toObject","_objectSpread","map","isNeutralState","some","fromObject","object","Promise","all","classRegistry","getClass","type","then","enlivedFilters","_defineProperty","setClass"],"mappings":"2TAQO,MAAMA,UAAiBC,EAQ5BC,WAAAA,GAG6D,IAAAC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAJ,CAAE,GAH/CG,WACVA,EAAa,IAEuCJ,EACpDK,MAFUC,EAAAN,EAAAO,IAGVC,KAAKJ,WAAaA,CACpB,CAQAK,OAAAA,CAAQC,GACFC,EAAqBD,KACvBA,EAAQE,QAAUJ,KAAKJ,WAAWF,OAAS,GAE7CM,KAAKJ,WAAWS,SAASC,IACvBA,EAAOL,QAAQC,EAAQ,GAE3B,CAOAK,QAAAA,GACE,OAAAC,EAAAA,EAAA,CAAA,EACKX,MAAMU,YAAU,GAAA,CACnBX,WAAYI,KAAKJ,WAAWa,KAAKH,GAAWA,EAAOC,cAEvD,CAEAG,cAAAA,GACE,OAAQV,KAAKJ,WAAWe,MAAML,IAAYA,EAAOI,kBACnD,CAUA,iBAAOE,CACLC,EACAX,GAEA,OAAOY,QAAQC,KACXF,EAAOjB,YAAc,IAAqBa,KAAKH,GAC/CU,EACGC,SAA4BX,EAAOY,MACnCN,WAAWN,EAAQJ,MAExBiB,MACCC,GAAmB,IAAIpB,KAAK,CAAEJ,WAAYwB,KAE/C,EAnEAC,EADWhC,EAAQ,OAML,YAiEhB2B,EAAcM,SAASjC"}