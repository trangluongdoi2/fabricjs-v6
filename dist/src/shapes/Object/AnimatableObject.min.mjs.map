{"version":3,"file":"AnimatableObject.min.mjs","sources":["../../../../src/shapes/Object/AnimatableObject.ts"],"sourcesContent":["import type { TColorArg } from '../../color/typedefs';\nimport type { ObjectEvents } from '../../EventTypeDefs';\nimport type { TAnimation } from '../../util/animation/animate';\nimport { animate, animateColor } from '../../util/animation/animate';\nimport type {\n  AnimationOptions,\n  ArrayAnimationOptions,\n  ColorAnimationOptions,\n  ValueAnimationOptions,\n} from '../../util/animation/types';\nimport { StackedObject } from './StackedObject';\n\nexport abstract class AnimatableObject<\n  EventSpec extends ObjectEvents = ObjectEvents\n> extends StackedObject<EventSpec> {\n  /**\n   * List of properties to consider for animating colors.\n   * @type String[]\n   */\n  static colorProperties: string[] = ['fill', 'stroke', 'backgroundColor'];\n\n  /**\n   * Animates object's properties\n   * @param {Record<string, number | number[] | TColorArg>} animatable map of keys and end values\n   * @param {Partial<AnimationOptions<T>>} options\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @return {Record<string, TAnimation<T>>} map of animation contexts\n   *\n   * As object â€” multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   */\n  animate<T extends number | number[] | TColorArg>(\n    animatable: Record<string, T>,\n    options?: Partial<AnimationOptions<T>>\n  ): Record<string, TAnimation<T>> {\n    return Object.entries(animatable).reduce((acc, [key, endValue]) => {\n      acc[key] = this._animate(key, endValue, options);\n      return acc;\n    }, {} as Record<string, TAnimation<T>>);\n  }\n\n  /**\n   * @private\n   * @param {String} key Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   */\n  _animate<T extends number | number[] | TColorArg>(\n    key: string,\n    endValue: T,\n    options: Partial<AnimationOptions<T>> = {}\n  ): TAnimation<T> {\n    const path = key.split('.');\n    const propIsColor = (\n      this.constructor as typeof AnimatableObject\n    ).colorProperties.includes(path[path.length - 1]);\n    const { easing, duration, abort, startValue, onChange, onComplete } =\n      options;\n    const animationOptions = {\n      target: this,\n      // path.reduce... is the current value in case start value isn't provided\n      startValue:\n        startValue ?? path.reduce((deep: any, key) => deep[key], this),\n      endValue,\n      easing,\n      duration,\n      abort: abort?.bind(this),\n      onChange: (\n        value: number | number[] | string,\n        valueProgress: number,\n        durationProgress: number\n      ) => {\n        path.reduce((deep: Record<string, any>, key, index) => {\n          if (index === path.length - 1) {\n            deep[key] = value;\n          }\n          return deep[key];\n        }, this);\n        onChange &&\n          // @ts-expect-error generic callback arg0 is wrong\n          onChange(value, valueProgress, durationProgress);\n      },\n      onComplete: (\n        value: number | number[] | string,\n        valueProgress: number,\n        durationProgress: number\n      ) => {\n        this.setCoords();\n        onComplete &&\n          // @ts-expect-error generic callback arg0 is wrong\n          onComplete(value, valueProgress, durationProgress);\n      },\n    } as AnimationOptions<T>;\n\n    return (\n      propIsColor\n        ? animateColor(animationOptions as ColorAnimationOptions)\n        : animate(\n            animationOptions as ValueAnimationOptions | ArrayAnimationOptions\n          )\n    ) as TAnimation<T>;\n  }\n}\n"],"names":["AnimatableObject","StackedObject","animate","animatable","options","Object","entries","reduce","acc","_ref","key","endValue","this","_animate","arguments","length","undefined","path","split","propIsColor","constructor","colorProperties","includes","easing","duration","abort","startValue","onChange","onComplete","animationOptions","target","deep","bind","value","valueProgress","durationProgress","index","setCoords","animateColor","_defineProperty"],"mappings":"8NAYO,MAAeA,UAEZC,EAmBRC,OAAAA,CACEC,EACAC,GAEA,OAAOC,OAAOC,QAAQH,GAAYI,QAAO,CAACC,EAAGC,KAAsB,IAAnBC,EAAKC,GAASF,EAE5D,OADAD,EAAIE,GAAOE,KAAKC,SAASH,EAAKC,EAAUP,GACjCI,CAAG,GACT,CAAmC,EACxC,CAQAK,QAAAA,CACEH,EACAC,GAEe,IADfP,EAAqCU,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAA,EAExC,MAAMG,EAAOP,EAAIQ,MAAM,KACjBC,EACJP,KAAKQ,YACLC,gBAAgBC,SAASL,EAAKA,EAAKF,OAAS,KACxCQ,OAAEA,EAAMC,SAAEA,EAAQC,MAAEA,EAAKC,WAAEA,EAAUC,SAAEA,EAAQC,WAAEA,GACrDxB,EACIyB,EAAmB,CACvBC,OAAQlB,KAERc,WACEA,QAAAA,EAAcT,EAAKV,QAAO,CAACwB,EAAWrB,IAAQqB,EAAKrB,IAAME,MAC3DD,WACAY,SACAC,WACAC,MAAOA,aAAK,EAALA,EAAOO,KAAKpB,MACnBe,SAAUA,CACRM,EACAC,EACAC,KAEAlB,EAAKV,QAAO,CAACwB,EAA2BrB,EAAK0B,KACvCA,IAAUnB,EAAKF,OAAS,IAC1BgB,EAAKrB,GAAOuB,GAEPF,EAAKrB,KACXE,MACHe,GAEEA,EAASM,EAAOC,EAAeC,EAAiB,EAEpDP,WAAYA,CACVK,EACAC,EACAC,KAEAvB,KAAKyB,YACLT,GAEEA,EAAWK,EAAOC,EAAeC,EAAiB,GAIxD,OACEhB,EACImB,EAAaT,GACb3B,EACE2B,EAGV,EAxFAU,EAHoBvC,EAOe,kBAAA,CAAC,OAAQ,SAAU"}