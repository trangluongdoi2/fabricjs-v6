import{iMatrix as t}from"../../constants.min.mjs";import{Intersection as i}from"../../Intersection.min.mjs";import{Point as s}from"../../Point.min.mjs";import{makeBoundingBoxFromPoints as e}from"../../util/misc/boundingBoxFromPoints.min.mjs";import{transformPoint as r,invertTransform as n,calcPlaneRotation as o,createRotateMatrix as h,multiplyTransformMatrices as a,composeMatrix as c,createTranslateMatrix as l}from"../../util/misc/matrix.min.mjs";import{radiansToDegrees as g}from"../../util/misc/radiansDegreesConversion.min.mjs";import{ObjectOrigin as d}from"./ObjectOrigin.min.mjs";class u extends d{getX(){return this.getXY().x}setX(t){this.setXY(this.getXY().setX(t))}getY(){return this.getXY().y}setY(t){this.setXY(this.getXY().setY(t))}getRelativeX(){return this.left}setRelativeX(t){this.left=t}getRelativeY(){return this.top}setRelativeY(t){this.top=t}getXY(){const t=this.getRelativeXY();return this.group?r(t,this.group.calcTransformMatrix()):t}setXY(t,i,s){this.group&&(t=r(t,n(this.group.calcTransformMatrix()))),this.setRelativeXY(t,i,s)}getRelativeXY(){return new s(this.left,this.top)}setRelativeXY(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.originX,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.originY;this.setPositionByOrigin(t,i,s)}isStrokeAccountedForInDimensions(){return!1}getCoords(){const{tl:t,tr:i,br:s,bl:e}=this.aCoords||(this.aCoords=this.calcACoords()),n=[t,i,s,e];if(this.group){const t=this.group.calcTransformMatrix();return n.map((i=>r(i,t)))}return n}intersectsWithRect(t,s){return"Intersection"===i.intersectPolygonRectangle(this.getCoords(),t,s).status}intersectsWithObject(t){const s=i.intersectPolygonPolygon(this.getCoords(),t.getCoords());return"Intersection"===s.status||"Coincident"===s.status||t.isContainedWithinObject(this)||this.isContainedWithinObject(t)}isContainedWithinObject(t){return this.getCoords().every((i=>t.containsPoint(i)))}isContainedWithinRect(t,i){const{left:s,top:e,width:r,height:n}=this.getBoundingRect();return s>=t.x&&s+r<=i.x&&e>=t.y&&e+n<=i.y}isOverlapping(t){return this.intersectsWithObject(t)||this.isContainedWithinObject(t)||t.isContainedWithinObject(this)}containsPoint(t){return i.isPointInPolygon(t,this.getCoords())}isOnScreen(){if(!this.canvas)return!1;const{tl:t,br:i}=this.canvas.vptCoords;return!!this.getCoords().some((s=>s.x<=i.x&&s.x>=t.x&&s.y<=i.y&&s.y>=t.y))||(!!this.intersectsWithRect(t,i)||this.containsPoint(t.midPointFrom(i)))}isPartiallyOnScreen(){if(!this.canvas)return!1;const{tl:t,br:i}=this.canvas.vptCoords;if(this.intersectsWithRect(t,i))return!0;return this.getCoords().every((s=>(s.x>=i.x||s.x<=t.x)&&(s.y>=i.y||s.y<=t.y)))&&this.containsPoint(t.midPointFrom(i))}getBoundingRect(){return e(this.getCoords())}getScaledWidth(){return this._getTransformedDimensions().x}getScaledHeight(){return this._getTransformedDimensions().y}scale(t){this._set("scaleX",t),this._set("scaleY",t),this.setCoords()}scaleToWidth(t){const i=this.getBoundingRect().width/this.getScaledWidth();return this.scale(t/this.width/i)}scaleToHeight(t){const i=this.getBoundingRect().height/this.getScaledHeight();return this.scale(t/this.height/i)}getCanvasRetinaScaling(){var t;return(null===(t=this.canvas)||void 0===t?void 0:t.getRetinaScaling())||1}getTotalAngle(){return this.group?g(o(this.calcTransformMatrix())):this.angle}getViewportTransform(){var i;return(null===(i=this.canvas)||void 0===i?void 0:i.viewportTransform)||t.concat()}calcACoords(){const t=h({angle:this.angle}),{x:i,y:s}=this.getRelativeCenterPoint(),e=l(i,s),n=a(e,t),o=this._getTransformedDimensions(),c=o.x/2,g=o.y/2;return{tl:r({x:-c,y:-g},n),tr:r({x:c,y:-g},n),bl:r({x:-c,y:g},n),br:r({x:c,y:g},n)}}setCoords(){this.aCoords=this.calcACoords()}transformMatrixKey(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i="_";let s="";return!t&&this.group&&(s=this.group.transformMatrixKey(t)+i),s+this.top+i+this.left+i+this.scaleX+i+this.scaleY+i+this.skewX+i+this.skewY+i+this.angle+i+this.originX+i+this.originY+i+this.width+i+this.height+i+this.strokeWidth+this.flipX+this.flipY}calcTransformMatrix(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.calcOwnMatrix();if(t||!this.group)return i;const s=this.transformMatrixKey(t),e=this.matrixCache;return e&&e.key===s?e.value:(this.group&&(i=a(this.group.calcTransformMatrix(!1),i)),this.matrixCache={key:s,value:i},i)}calcOwnMatrix(){const t=this.transformMatrixKey(!0),i=this.ownMatrixCache;if(i&&i.key===t)return i.value;const s=this.getRelativeCenterPoint(),e={angle:this.angle,translateX:s.x,translateY:s.y,scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,flipX:this.flipX,flipY:this.flipY},r=c(e);return this.ownMatrixCache={key:t,value:r},r}_getNonTransformedDimensions(){return new s(this.width,this.height).scalarAdd(this.strokeWidth)}_calculateCurrentDimensions(t){return this._getTransformedDimensions(t).transform(this.getViewportTransform(),!0).scalarAdd(2*this.padding)}}export{u as ObjectGeometry};
//# sourceMappingURL=ObjectGeometry.min.mjs.map
