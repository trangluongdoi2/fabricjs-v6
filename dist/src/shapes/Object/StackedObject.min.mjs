import{ObjectGeometry as t}from"./ObjectGeometry.min.mjs";class o extends t{isDescendantOf(t){const{parent:o,group:e}=this;return o===t||e===t||this.canvas===t||!!o&&o.isDescendantOf(t)||!!e&&e!==o&&e.isDescendantOf(t)}getAncestors(t){const e=[];let n=this;do{var r;n=n instanceof o?null!==(r=n.parent)&&void 0!==r?r:t?void 0:n.canvas:void 0,n&&e.push(n)}while(n);return e}findCommonAncestors(t,o){if(this===t)return{fork:[],otherFork:[],common:[this,...this.getAncestors(o)]};const e=this.getAncestors(o),n=t.getAncestors(o);if(0===e.length&&n.length>0&&this===n[n.length-1])return{fork:[],otherFork:[t,...n.slice(0,n.length-1)],common:[this]};for(let o,r=0;r<e.length;r++){if(o=e[r],o===t)return{fork:[this,...e.slice(0,r)],otherFork:[],common:e.slice(r)};for(let s=0;s<n.length;s++){if(this===n[s])return{fork:[],otherFork:[t,...n.slice(0,s)],common:[this,...e]};if(o===n[s])return{fork:[this,...e.slice(0,r)],otherFork:[t,...n.slice(0,s)],common:e.slice(r)}}}return{fork:[this,...e],otherFork:[t,...n],common:[]}}hasCommonAncestors(t,o){const e=this.findCommonAncestors(t,o);return e&&!!e.common.length}isInFrontOf(t){if(this===t)return;const o=this.findCommonAncestors(t);if(!o)return;if(o.fork.includes(t))return!0;if(o.otherFork.includes(this))return!1;const e=o.common[0];if(!e)return;const n=o.fork.pop(),r=o.otherFork.pop(),s=e._objects.indexOf(n),i=e._objects.indexOf(r);return s>-1&&s>i}}export{o as StackedObject};
//# sourceMappingURL=StackedObject.min.mjs.map
