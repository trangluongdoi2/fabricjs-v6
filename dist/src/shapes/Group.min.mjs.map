{"version":3,"file":"Group.min.mjs","sources":["../../../src/shapes/Group.ts"],"sourcesContent":["import type { CollectionEvents, ObjectEvents } from '../EventTypeDefs';\nimport { createCollectionMixin } from '../Collection';\nimport type { TClassProperties, TSVGReviver, TOptions } from '../typedefs';\nimport {\n  invertTransform,\n  multiplyTransformMatrices,\n} from '../util/misc/matrix';\nimport {\n  enlivenObjectEnlivables,\n  enlivenObjects,\n} from '../util/misc/objectEnlive';\nimport { applyTransformToObject } from '../util/misc/objectTransforms';\nimport { FabricObject } from './Object/FabricObject';\nimport { Rect } from './Rect';\nimport { classRegistry } from '../ClassRegistry';\nimport type { FabricObjectProps, SerializedObjectProps } from './Object/types';\nimport { log } from '../util/internals/console';\nimport type {\n  ImperativeLayoutOptions,\n  LayoutBeforeEvent,\n  LayoutAfterEvent,\n} from '../LayoutManager/types';\nimport { LayoutManager } from '../LayoutManager/LayoutManager';\nimport {\n  LAYOUT_TYPE_ADDED,\n  LAYOUT_TYPE_IMPERATIVE,\n  LAYOUT_TYPE_INITIALIZATION,\n  LAYOUT_TYPE_REMOVED,\n} from '../LayoutManager/constants';\nimport type { SerializedLayoutManager } from '../LayoutManager/LayoutManager';\nimport type { FitContentLayout } from '../LayoutManager';\n\n/**\n * This class handles the specific case of creating a group using {@link Group#fromObject} and is not meant to be used in any other case.\n * We could have used a boolean in the constructor, as we did previously, but we think the boolean\n * would stay in the group's constructor interface and create confusion, therefore it was removed.\n * This layout manager doesn't do anything and therefore keeps the exact layout the group had when {@link Group#toObject} was called.\n */\nclass NoopLayoutManager extends LayoutManager {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  performLayout() {}\n}\n\nexport interface GroupEvents extends ObjectEvents, CollectionEvents {\n  'layout:before': LayoutBeforeEvent;\n  'layout:after': LayoutAfterEvent;\n}\n\nexport interface GroupOwnProps {\n  subTargetCheck: boolean;\n  interactive: boolean;\n}\n\nexport interface SerializedGroupProps\n  extends SerializedObjectProps,\n    GroupOwnProps {\n  objects: SerializedObjectProps[];\n  layoutManager: SerializedLayoutManager;\n}\n\nexport interface GroupProps extends FabricObjectProps, GroupOwnProps {\n  layoutManager: LayoutManager;\n}\n\nexport const groupDefaultValues: Partial<TClassProperties<Group>> = {\n  strokeWidth: 0,\n  subTargetCheck: false,\n  interactive: false,\n};\n\n/**\n * @fires object:added\n * @fires object:removed\n * @fires layout:before\n * @fires layout:after\n */\nexport class Group\n  extends createCollectionMixin(\n    FabricObject<GroupProps, SerializedGroupProps, GroupEvents>\n  )\n  implements GroupProps\n{\n  /**\n   * Used to optimize performance\n   * set to `false` if you don't need contained objects to be targets of events\n   * @default\n   * @type boolean\n   */\n  declare subTargetCheck: boolean;\n\n  /**\n   * Used to allow targeting of object inside groups.\n   * set to true if you want to select an object inside a group.\\\n   * **REQUIRES** `subTargetCheck` set to true\n   * @default\n   * @type boolean\n   */\n  declare interactive: boolean;\n\n  declare layoutManager: LayoutManager;\n\n  /**\n   * Used internally to optimize performance\n   * Once an object is selected, instance is rendered without the selected object.\n   * This way instance is cached only once for the entire interaction with the selected object.\n   * @private\n   */\n  protected _activeObjects: FabricObject[] = [];\n\n  static type = 'Group';\n\n  static ownDefaults: Record<string, any> = groupDefaultValues;\n  private __objectSelectionTracker: (ev: ObjectEvents['selected']) => void;\n  private __objectSelectionDisposer: (ev: ObjectEvents['deselected']) => void;\n\n  static getDefaults(): Record<string, any> {\n    return {\n      ...super.getDefaults(),\n      ...Group.ownDefaults,\n    };\n  }\n\n  /**\n   * Constructor\n   *\n   * @param {FabricObject[]} [objects] instance objects\n   * @param {Object} [options] Options object\n   */\n  constructor(objects: FabricObject[] = [], options: Partial<GroupProps> = {}) {\n    // @ts-expect-error options error\n    super(options);\n    this._objects = [...objects]; // Avoid unwanted mutations of Collection to affect the caller\n\n    this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(\n      this,\n      true\n    );\n    this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(\n      this,\n      false\n    );\n\n    this.forEachObject((object) => {\n      this.enterGroup(object, false);\n    });\n\n    // perform initial layout\n    this.layoutManager = options.layoutManager || new LayoutManager();\n    this.layoutManager.performLayout({\n      type: LAYOUT_TYPE_INITIALIZATION,\n      target: this,\n      targets: [...objects],\n      x: options.left,\n      y: options.top,\n    });\n  }\n\n  /**\n   * Checks if object can enter group and logs relevant warnings\n   * @private\n   * @param {FabricObject} object\n   * @returns\n   */\n  canEnterGroup(object: FabricObject) {\n    if (object === this || this.isDescendantOf(object)) {\n      //  prevent circular object tree\n      log(\n        'error',\n        'Group: circular object trees are not supported, this call has no effect'\n      );\n      return false;\n    } else if (this._objects.indexOf(object) !== -1) {\n      // is already in the objects array\n      log(\n        'error',\n        'Group: duplicate objects are not supported inside group, this call has no effect'\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Override this method to enhance performance (for groups with a lot of objects).\n   * If Overriding, be sure not pass illegal objects to group - it will break your app.\n   * @private\n   */\n  protected _filterObjectsBeforeEnteringGroup(objects: FabricObject[]) {\n    return objects.filter((object, index, array) => {\n      // can enter AND is the first occurrence of the object in the passed args (to prevent adding duplicates)\n      return this.canEnterGroup(object) && array.indexOf(object) === index;\n    });\n  }\n\n  /**\n   * Add objects\n   * @param {...FabricObject[]} objects\n   */\n  add(...objects: FabricObject[]) {\n    const allowedObjects = this._filterObjectsBeforeEnteringGroup(objects);\n    const size = super.add(...allowedObjects);\n    this._onAfterObjectsChange(LAYOUT_TYPE_ADDED, allowedObjects);\n    return size;\n  }\n\n  /**\n   * Inserts an object into collection at specified index\n   * @param {FabricObject[]} objects Object to insert\n   * @param {Number} index Index to insert object at\n   */\n  insertAt(index: number, ...objects: FabricObject[]) {\n    const allowedObjects = this._filterObjectsBeforeEnteringGroup(objects);\n    const size = super.insertAt(index, ...allowedObjects);\n    this._onAfterObjectsChange(LAYOUT_TYPE_ADDED, allowedObjects);\n    return size;\n  }\n\n  /**\n   * Remove objects\n   * @param {...FabricObject[]} objects\n   * @returns {FabricObject[]} removed objects\n   */\n  remove(...objects: FabricObject[]) {\n    const removed = super.remove(...objects);\n    this._onAfterObjectsChange(LAYOUT_TYPE_REMOVED, removed);\n    return removed;\n  }\n\n  _onObjectAdded(object: FabricObject) {\n    this.enterGroup(object, true);\n    this.fire('object:added', { target: object });\n    object.fire('added', { target: this });\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object should exit group without applying group's transform to it\n   */\n  _onObjectRemoved(object: FabricObject, removeParentTransform?: boolean) {\n    this.exitGroup(object, removeParentTransform);\n    this.fire('object:removed', { target: object });\n    object.fire('removed', { target: this });\n  }\n\n  /**\n   * @private\n   * @param {'added'|'removed'} type\n   * @param {FabricObject[]} targets\n   */\n  _onAfterObjectsChange(type: 'added' | 'removed', targets: FabricObject[]) {\n    this.layoutManager.performLayout({\n      type,\n      targets,\n      target: this,\n    });\n  }\n\n  _onStackOrderChanged() {\n    this._set('dirty', true);\n  }\n\n  /**\n   * @private\n   * @param {string} key\n   * @param {*} value\n   */\n  _set(key: string, value: any) {\n    const prev = this[key as keyof this];\n    super._set(key, value);\n    if (key === 'canvas' && prev !== value) {\n      (this._objects || []).forEach((object) => {\n        object._set(key, value);\n      });\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   */\n  _shouldSetNestedCoords() {\n    return this.subTargetCheck;\n  }\n\n  /**\n   * Remove all objects\n   * @returns {FabricObject[]} removed objects\n   */\n  removeAll() {\n    this._activeObjects = [];\n    return this.remove(...this._objects);\n  }\n\n  /**\n   * keeps track of the selected objects\n   * @private\n   */\n  __objectSelectionMonitor<T extends boolean>(\n    selected: T,\n    { target: object }: ObjectEvents[T extends true ? 'selected' : 'deselected']\n  ) {\n    if (selected) {\n      this._activeObjects.push(object);\n      this._set('dirty', true);\n    } else if (this._activeObjects.length > 0) {\n      const index = this._activeObjects.indexOf(object);\n      if (index > -1) {\n        this._activeObjects.splice(index, 1);\n        this._set('dirty', true);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {boolean} watch\n   * @param {FabricObject} object\n   */\n  _watchObject(watch: boolean, object: FabricObject) {\n    //  make sure we listen only once\n    watch && this._watchObject(false, object);\n    if (watch) {\n      object.on('selected', this.__objectSelectionTracker);\n      object.on('deselected', this.__objectSelectionDisposer);\n    } else {\n      object.off('selected', this.__objectSelectionTracker);\n      object.off('deselected', this.__objectSelectionDisposer);\n    }\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object is in canvas coordinate plane\n   */\n  enterGroup(object: FabricObject, removeParentTransform?: boolean) {\n    object.group && object.group.remove(object);\n    object._set('parent', this);\n    this._enterGroup(object, removeParentTransform);\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object is in canvas coordinate plane\n   */\n  _enterGroup(object: FabricObject, removeParentTransform?: boolean) {\n    if (removeParentTransform) {\n      // can this be converted to utils (sendObjectToPlane)?\n      applyTransformToObject(\n        object,\n        multiplyTransformMatrices(\n          invertTransform(this.calcTransformMatrix()),\n          object.calcTransformMatrix()\n        )\n      );\n    }\n    this._shouldSetNestedCoords() && object.setCoords();\n    object._set('group', this);\n    object._set('canvas', this.canvas);\n    this._watchObject(true, object);\n    const activeObject =\n      this.canvas &&\n      this.canvas.getActiveObject &&\n      this.canvas.getActiveObject();\n    // if we are adding the activeObject in a group\n    if (\n      activeObject &&\n      (activeObject === object || object.isDescendantOf(activeObject))\n    ) {\n      this._activeObjects.push(object);\n    }\n  }\n\n  /**\n   * @private\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object should exit group without applying group's transform to it\n   */\n  exitGroup(object: FabricObject, removeParentTransform?: boolean) {\n    this._exitGroup(object, removeParentTransform);\n    object._set('parent', undefined);\n    object._set('canvas', undefined);\n  }\n\n  /**\n   * Executes the inner fabric logic of exiting a group.\n   * - Stop watching the object\n   * - Remove the object from the optimization map this._activeObjects\n   * - unset the group property of the object\n   * @protected\n   * @param {FabricObject} object\n   * @param {boolean} [removeParentTransform] true if object should exit group without applying group's transform to it\n   */\n  _exitGroup(object: FabricObject, removeParentTransform?: boolean) {\n    object._set('group', undefined);\n    if (!removeParentTransform) {\n      applyTransformToObject(\n        object,\n        multiplyTransformMatrices(\n          this.calcTransformMatrix(),\n          object.calcTransformMatrix()\n        )\n      );\n      object.setCoords();\n    }\n    this._watchObject(false, object);\n    const index =\n      this._activeObjects.length > 0 ? this._activeObjects.indexOf(object) : -1;\n    if (index > -1) {\n      this._activeObjects.splice(index, 1);\n    }\n  }\n\n  /**\n   * Decide if the object should cache or not. Create its own cache level\n   * needsItsOwnCache should be used when the object drawing method requires\n   * a cache step. None of the fabric classes requires it.\n   * Generally you do not cache objects in groups because the group is already cached.\n   * @return {Boolean}\n   */\n  shouldCache() {\n    const ownCache = FabricObject.prototype.shouldCache.call(this);\n    if (ownCache) {\n      for (let i = 0; i < this._objects.length; i++) {\n        if (this._objects[i].willDrawShadow()) {\n          this.ownCaching = false;\n          return false;\n        }\n      }\n    }\n    return ownCache;\n  }\n\n  /**\n   * Check if this object or a child object will cast a shadow\n   * @return {Boolean}\n   */\n  willDrawShadow() {\n    if (super.willDrawShadow()) {\n      return true;\n    }\n    for (let i = 0; i < this._objects.length; i++) {\n      if (this._objects[i].willDrawShadow()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if instance or its group are caching, recursively up\n   * @return {Boolean}\n   */\n  isOnACache(): boolean {\n    return this.ownCaching || (!!this.group && this.group.isOnACache());\n  }\n\n  /**\n   * Execute the drawing operation for an object on a specified context\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  drawObject(ctx: CanvasRenderingContext2D) {\n    this._renderBackground(ctx);\n    for (let i = 0; i < this._objects.length; i++) {\n      // TODO: handle rendering edge case somehow\n      if (\n        this.canvas?.preserveObjectStacking &&\n        this._objects[i].group !== this\n      ) {\n        ctx.save();\n        ctx.transform(...invertTransform(this.calcTransformMatrix()));\n        this._objects[i].render(ctx);\n        ctx.restore();\n      } else if (this._objects[i].group === this) {\n        this._objects[i].render(ctx);\n      }\n    }\n    this._drawClipPath(ctx, this.clipPath);\n  }\n\n  /**\n   * @override\n   * @return {Boolean}\n   */\n  setCoords() {\n    super.setCoords();\n    this._shouldSetNestedCoords() &&\n      this.forEachObject((object) => object.setCoords());\n  }\n\n  triggerLayout(options: ImperativeLayoutOptions = {}) {\n    this.layoutManager.performLayout({\n      target: this,\n      type: LAYOUT_TYPE_IMPERATIVE,\n      ...options,\n    });\n  }\n\n  /**\n   * Renders instance on a given context\n   * @param {CanvasRenderingContext2D} ctx context to render instance on\n   */\n  render(ctx: CanvasRenderingContext2D) {\n    this._transformDone = true;\n    super.render(ctx);\n    this._transformDone = false;\n  }\n\n  /**\n   *\n   * @private\n   * @param {'toObject'|'toDatalessObject'} [method]\n   * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @returns {FabricObject[]} serialized objects\n   */\n  __serializeObjects(\n    method: 'toObject' | 'toDatalessObject',\n    propertiesToInclude?: string[]\n  ) {\n    const _includeDefaultValues = this.includeDefaultValues;\n    return this._objects\n      .filter(function (obj) {\n        return !obj.excludeFromExport;\n      })\n      .map(function (obj) {\n        const originalDefaults = obj.includeDefaultValues;\n        obj.includeDefaultValues = _includeDefaultValues;\n        const data = obj[method || 'toObject'](propertiesToInclude);\n        obj.includeDefaultValues = originalDefaults;\n        // delete data.version;\n        return data;\n      });\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} object representation of an instance\n   */\n  toObject<\n    T extends Omit<\n      GroupProps & TClassProperties<this>,\n      keyof SerializedGroupProps\n    >,\n    K extends keyof T = never\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SerializedGroupProps {\n    const layoutManager = this.layoutManager.toObject();\n\n    return {\n      ...super.toObject([\n        'subTargetCheck',\n        'interactive',\n        ...propertiesToInclude,\n      ]),\n      ...(layoutManager.strategy !== 'fit-content' || this.includeDefaultValues\n        ? { layoutManager }\n        : {}),\n      objects: this.__serializeObjects(\n        'toObject',\n        propertiesToInclude as string[]\n      ),\n    };\n  }\n\n  toString() {\n    return `#<Group: (${this.complexity()})>`;\n  }\n\n  dispose() {\n    this.layoutManager.unsubscribeTargets({\n      targets: this.getObjects(),\n      target: this,\n    });\n    this._activeObjects = [];\n    this.forEachObject((object) => {\n      this._watchObject(false, object);\n      object.dispose();\n    });\n    super.dispose();\n  }\n\n  /**\n   * @private\n   */\n  _createSVGBgRect(reviver?: TSVGReviver) {\n    if (!this.backgroundColor) {\n      return '';\n    }\n    const fillStroke = Rect.prototype._toSVG.call(this);\n    const commons = fillStroke.indexOf('COMMON_PARTS');\n    fillStroke[commons] = 'for=\"group\" ';\n    const markup = fillStroke.join('');\n    return reviver ? reviver(markup) : markup;\n  }\n\n  /**\n   * Returns svg representation of an instance\n   * @param {TSVGReviver} [reviver] Method for further parsing of svg representation.\n   * @return {String} svg representation of an instance\n   */\n  _toSVG(reviver?: TSVGReviver) {\n    const svgString = ['<g ', 'COMMON_PARTS', ' >\\n'];\n    const bg = this._createSVGBgRect(reviver);\n    bg && svgString.push('\\t\\t', bg);\n    for (let i = 0; i < this._objects.length; i++) {\n      svgString.push('\\t\\t', this._objects[i].toSVG(reviver));\n    }\n    svgString.push('</g>\\n');\n    return svgString;\n  }\n\n  /**\n   * Returns styles-string for svg-export, specific version for group\n   * @return {String}\n   */\n  getSvgStyles(): string {\n    const opacity =\n        typeof this.opacity !== 'undefined' && this.opacity !== 1\n          ? `opacity: ${this.opacity};`\n          : '',\n      visibility = this.visible ? '' : ' visibility: hidden;';\n    return [opacity, this.getSvgFilter(), visibility].join('');\n  }\n\n  /**\n   * Returns svg clipPath representation of an instance\n   * @param {Function} [reviver] Method for further parsing of svg representation.\n   * @return {String} svg representation of an instance\n   */\n  toClipPathSVG(reviver?: TSVGReviver): string {\n    const svgString = [];\n    const bg = this._createSVGBgRect(reviver);\n    bg && svgString.push('\\t', bg);\n    for (let i = 0; i < this._objects.length; i++) {\n      svgString.push('\\t', this._objects[i].toClipPathSVG(reviver));\n    }\n    return this._createBaseClipPathSVGMarkup(svgString, {\n      reviver,\n    });\n  }\n\n  /**\n   * @todo support loading from svg\n   * @private\n   * @static\n   * @memberOf Group\n   * @param {Object} object Object to create a group from\n   * @returns {Promise<Group>}\n   */\n  static fromObject<T extends TOptions<SerializedGroupProps>>({\n    type,\n    objects = [],\n    layoutManager,\n    ...options\n  }: T) {\n    return Promise.all([\n      enlivenObjects<FabricObject>(objects),\n      enlivenObjectEnlivables(options),\n    ]).then(([objects, hydratedOptions]) => {\n      const group = new this(objects, {\n        ...options,\n        ...hydratedOptions,\n        layoutManager: new NoopLayoutManager(),\n      });\n      if (layoutManager) {\n        const layoutClass = classRegistry.getClass<typeof LayoutManager>(\n          layoutManager.type\n        );\n        const strategyClass = classRegistry.getClass<typeof FitContentLayout>(\n          layoutManager.strategy\n        );\n        group.layoutManager = new layoutClass(new strategyClass());\n      } else {\n        group.layoutManager = new LayoutManager();\n      }\n      group.layoutManager.subscribeTargets({\n        type: LAYOUT_TYPE_INITIALIZATION,\n        target: group,\n        targets: group.getObjects(),\n      });\n      group.setCoords();\n      return group;\n    });\n  }\n}\n\nclassRegistry.setClass(Group);\n"],"names":["NoopLayoutManager","LayoutManager","performLayout","groupDefaultValues","strokeWidth","subTargetCheck","interactive","Group","createCollectionMixin","FabricObject","getDefaults","_objectSpread","super","ownDefaults","constructor","objects","arguments","length","undefined","options","_defineProperty","this","_objects","__objectSelectionTracker","__objectSelectionMonitor","bind","__objectSelectionDisposer","forEachObject","object","enterGroup","layoutManager","type","LAYOUT_TYPE_INITIALIZATION","target","targets","x","left","y","top","canEnterGroup","isDescendantOf","log","indexOf","_filterObjectsBeforeEnteringGroup","filter","index","array","add","_len","Array","_key","allowedObjects","size","_onAfterObjectsChange","LAYOUT_TYPE_ADDED","insertAt","_len2","_key2","remove","removed","LAYOUT_TYPE_REMOVED","_onObjectAdded","fire","_onObjectRemoved","removeParentTransform","exitGroup","_onStackOrderChanged","_set","key","value","prev","forEach","_shouldSetNestedCoords","removeAll","_activeObjects","selected","_ref","push","splice","_watchObject","watch","on","off","group","_enterGroup","applyTransformToObject","multiplyTransformMatrices","invertTransform","calcTransformMatrix","setCoords","canvas","activeObject","getActiveObject","_exitGroup","shouldCache","ownCache","prototype","call","i","willDrawShadow","ownCaching","isOnACache","drawObject","ctx","_renderBackground","_this$canvas","preserveObjectStacking","save","transform","render","restore","_drawClipPath","clipPath","triggerLayout","LAYOUT_TYPE_IMPERATIVE","_transformDone","__serializeObjects","method","propertiesToInclude","_includeDefaultValues","includeDefaultValues","obj","excludeFromExport","map","originalDefaults","data","toObject","strategy","toString","concat","complexity","dispose","unsubscribeTargets","getObjects","_createSVGBgRect","reviver","backgroundColor","fillStroke","Rect","_toSVG","commons","markup","join","svgString","bg","toSVG","getSvgStyles","opacity","visibility","visible","getSvgFilter","toClipPathSVG","_createBaseClipPathSVGMarkup","fromObject","_ref2","_objectWithoutProperties","_excluded","Promise","all","enlivenObjects","enlivenObjectEnlivables","then","_ref3","hydratedOptions","layoutClass","classRegistry","getClass","strategyClass","subscribeTargets","setClass"],"mappings":"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"}