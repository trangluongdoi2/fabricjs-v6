import{defineProperty as t,objectSpread2 as i,objectWithoutProperties as s}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{config as e}from"../config.min.mjs";import{SHARED_ATTRIBUTES as o}from"../parser/attributes.min.mjs";import{parseAttributes as n}from"../parser/parseAttributes.min.mjs";import{parsePointsAttribute as r}from"../parser/parsePointsAttribute.min.mjs";import{Point as h}from"../Point.min.mjs";import{classRegistry as m}from"../ClassRegistry.min.mjs";import{makeBoundingBoxFromPoints as a}from"../util/misc/boundingBoxFromPoints.min.mjs";import{calcDimensionsMatrix as p,transformPoint as l}from"../util/misc/matrix.min.mjs";import{projectStrokeOnPoints as c}from"../util/misc/projectStroke/index.min.mjs";import{degreesToRadians as f}from"../util/misc/radiansDegreesConversion.min.mjs";import{toFixed as u}from"../util/misc/toFixed.min.mjs";import{FabricObject as d}from"./Object/FabricObject.min.mjs";import{cloneDeep as g}from"../util/internals/cloneDeep.min.mjs";import{LEFT as k,TOP as w,CENTER as j}from"../constants.min.mjs";import{cacheProperties as x}from"./Object/defaultValues.min.mjs";const O=["left","top"],B={exactBoundingBox:!1};class y extends d{static getDefaults(){return i(i({},super.getDefaults()),y.ownDefaults)}constructor(){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(i({points:arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]},s)),t(this,"strokeDiff",void 0);const{left:e,top:o}=s;this.initialized=!0,this.setBoundingBox(!0),"number"==typeof e&&this.set(k,e),"number"==typeof o&&this.set(w,o)}isOpen(){return!0}_projectStrokeOnPoints(t){return c(this.points,t,this.isOpen())}_calcDimensions(t){t=i({scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,strokeLineCap:this.strokeLineCap,strokeLineJoin:this.strokeLineJoin,strokeMiterLimit:this.strokeMiterLimit,strokeUniform:this.strokeUniform,strokeWidth:this.strokeWidth},t||{});const s=this.exactBoundingBox?this._projectStrokeOnPoints(t).map((t=>t.projectedPoint)):this.points;if(0===s.length)return{left:0,top:0,width:0,height:0,pathOffset:new h,strokeOffset:new h,strokeDiff:new h};const e=a(s),o=p(i(i({},t),{},{scaleX:1,scaleY:1})),n=a(this.points.map((t=>l(t,o,!0)))),r=new h(this.scaleX,this.scaleY);let m=e.left+e.width/2,c=e.top+e.height/2;return this.exactBoundingBox&&(m-=c*Math.tan(f(this.skewX)),c-=m*Math.tan(f(this.skewY))),i(i({},e),{},{pathOffset:new h(m,c),strokeOffset:new h(n.left,n.top).subtract(new h(e.left,e.top)).multiply(r),strokeDiff:new h(e.width,e.height).subtract(new h(n.width,n.height)).multiply(r)})}_findCenterFromElement(){const t=a(this.points);return new h(t.left+t.width/2,t.top+t.height/2)}setDimensions(){this.setBoundingBox()}setBoundingBox(t){const{left:i,top:s,width:e,height:o,pathOffset:n,strokeOffset:r,strokeDiff:m}=this._calcDimensions();this.set({width:e,height:o,pathOffset:n,strokeOffset:r,strokeDiff:m}),t&&this.setPositionByOrigin(new h(i+e/2,s+o/2),j,j)}isStrokeAccountedForInDimensions(){return this.exactBoundingBox}_getNonTransformedDimensions(){return this.exactBoundingBox?new h(this.width,this.height):super._getNonTransformedDimensions()}_getTransformedDimensions(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.exactBoundingBox){let n;if(Object.keys(t).some((t=>this.strokeUniform||this.constructor.layoutProperties.includes(t)))){var i,s;const{width:e,height:o}=this._calcDimensions(t);n=new h(null!==(i=t.width)&&void 0!==i?i:e,null!==(s=t.height)&&void 0!==s?s:o)}else{var e,o;n=new h(null!==(e=t.width)&&void 0!==e?e:this.width,null!==(o=t.height)&&void 0!==o?o:this.height)}return n.multiply(new h(t.scaleX||this.scaleX,t.scaleY||this.scaleY))}return super._getTransformedDimensions(t)}_set(t,i){const s=this.initialized&&this[t]!==i,e=super._set(t,i);return this.exactBoundingBox&&s&&(("scaleX"===t||"scaleY"===t)&&this.strokeUniform&&this.constructor.layoutProperties.includes("strokeUniform")||this.constructor.layoutProperties.includes(t))&&this.setDimensions(),e}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return i(i({},super.toObject(t)),{},{points:g(this.points)})}_toSVG(){const t=[],i=this.pathOffset.x,s=this.pathOffset.y,o=e.NUM_FRACTION_DIGITS;for(let e=0,n=this.points.length;e<n;e++)t.push(u(this.points[e].x-i,o),",",u(this.points[e].y-s,o)," ");return["<".concat(this.constructor.type.toLowerCase()," "),"COMMON_PARTS",'points="'.concat(t.join(""),'" />\n')]}_render(t){const i=this.points.length,s=this.pathOffset.x,e=this.pathOffset.y;if(i&&!isNaN(this.points[i-1].y)){t.beginPath(),t.moveTo(this.points[0].x-s,this.points[0].y-e);for(let o=0;o<i;o++){const i=this.points[o];t.lineTo(i.x-s,i.y-e)}!this.isOpen()&&t.closePath(),this._renderPaintInOrder(t)}}complexity(){return this.points.length}static async fromElement(t,e,o){const h=r(t.getAttribute("points")),m=n(t,this.ATTRIBUTE_NAMES,o),a=s(m,O);return new this(h,i(i({},a),e))}static fromObject(t){return this._fromObject(t,{extraParam:"points"})}}t(y,"ownDefaults",B),t(y,"type","Polyline"),t(y,"layoutProperties",["skewX","skewY","strokeLineCap","strokeLineJoin","strokeMiterLimit","strokeWidth","strokeUniform","points"]),t(y,"cacheProperties",[...x,"points"]),t(y,"ATTRIBUTE_NAMES",[...o]),m.setClass(y),m.setSVGClass(y);export{y as Polyline,B as polylineDefaultValues};
//# sourceMappingURL=Polyline.min.mjs.map
