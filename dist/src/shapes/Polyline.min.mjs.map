{"version":3,"file":"Polyline.min.mjs","sources":["../../../src/shapes/Polyline.ts"],"sourcesContent":["import { config } from '../config';\nimport { SHARED_ATTRIBUTES } from '../parser/attributes';\nimport { parseAttributes } from '../parser/parseAttributes';\nimport { parsePointsAttribute } from '../parser/parsePointsAttribute';\nimport type { XY } from '../Point';\nimport { Point } from '../Point';\nimport type { Abortable, TClassProperties, TOptions } from '../typedefs';\nimport { classRegistry } from '../ClassRegistry';\nimport { makeBoundingBoxFromPoints } from '../util/misc/boundingBoxFromPoints';\nimport { calcDimensionsMatrix, transformPoint } from '../util/misc/matrix';\nimport { projectStrokeOnPoints } from '../util/misc/projectStroke';\nimport type { TProjectStrokeOnPointsOptions } from '../util/misc/projectStroke/types';\nimport { degreesToRadians } from '../util/misc/radiansDegreesConversion';\nimport { toFixed } from '../util/misc/toFixed';\nimport { FabricObject, cacheProperties } from './Object/FabricObject';\nimport type { FabricObjectProps, SerializedObjectProps } from './Object/types';\nimport type { ObjectEvents } from '../EventTypeDefs';\nimport { cloneDeep } from '../util/internals/cloneDeep';\nimport { CENTER, LEFT, TOP } from '../constants';\nimport type { CSSRules } from '../parser/typedefs';\n\nexport const polylineDefaultValues: Partial<TClassProperties<Polyline>> = {\n  /**\n   * @deprecated transient option soon to be removed in favor of a different design\n   */\n  exactBoundingBox: false,\n};\n\nexport interface SerializedPolylineProps extends SerializedObjectProps {\n  points: XY[];\n}\n\nexport class Polyline<\n  Props extends TOptions<FabricObjectProps> = Partial<FabricObjectProps>,\n  SProps extends SerializedPolylineProps = SerializedPolylineProps,\n  EventSpec extends ObjectEvents = ObjectEvents\n> extends FabricObject<Props, SProps, EventSpec> {\n  /**\n   * Points array\n   * @type Array\n   * @default\n   */\n  declare points: XY[];\n\n  /**\n   * WARNING: Feature in progress\n   * Calculate the exact bounding box taking in account strokeWidth on acute angles\n   * this will be turned to true by default on fabric 6.0\n   * maybe will be left in as an optimization since calculations may be slow\n   * @deprecated transient option soon to be removed in favor of a different design\n   * @type Boolean\n   * @default false\n   */\n  declare exactBoundingBox: boolean;\n\n  private declare initialized: true | undefined;\n\n  static ownDefaults = polylineDefaultValues;\n\n  static type = 'Polyline';\n\n  static getDefaults(): Record<string, any> {\n    return {\n      ...super.getDefaults(),\n      ...Polyline.ownDefaults,\n    };\n  }\n  /**\n   * A list of properties that if changed trigger a recalculation of dimensions\n   * @todo check if you really need to recalculate for all cases\n   */\n  static layoutProperties: (keyof Polyline)[] = [\n    'skewX',\n    'skewY',\n    'strokeLineCap',\n    'strokeLineJoin',\n    'strokeMiterLimit',\n    'strokeWidth',\n    'strokeUniform',\n    'points',\n  ];\n\n  declare pathOffset: Point;\n\n  declare strokeOffset: Point;\n\n  static cacheProperties = [...cacheProperties, 'points'];\n\n  strokeDiff: Point;\n\n  /**\n   * Constructor\n   * @param {Array} points Array of points (where each point is an object with x and y)\n   * @param {Object} [options] Options object\n   * @return {Polyline} thisArg\n   * @example\n   * var poly = new Polyline([\n   *     { x: 10, y: 10 },\n   *     { x: 50, y: 30 },\n   *     { x: 40, y: 70 },\n   *     { x: 60, y: 50 },\n   *     { x: 100, y: 150 },\n   *     { x: 40, y: 100 }\n   *   ], {\n   *   stroke: 'red',\n   *   left: 100,\n   *   top: 100\n   * });\n   */\n  constructor(points: XY[] = [], options: Props = {} as Props) {\n    super({ points, ...options });\n    const { left, top } = options;\n    this.initialized = true;\n    this.setBoundingBox(true);\n    typeof left === 'number' && this.set(LEFT, left);\n    typeof top === 'number' && this.set(TOP, top);\n  }\n\n  protected isOpen() {\n    return true;\n  }\n\n  private _projectStrokeOnPoints(options: TProjectStrokeOnPointsOptions) {\n    return projectStrokeOnPoints(this.points, options, this.isOpen());\n  }\n\n  /**\n   * Calculate the polygon bounding box\n   * @private\n   */\n  _calcDimensions(options?: Partial<TProjectStrokeOnPointsOptions>) {\n    options = {\n      scaleX: this.scaleX,\n      scaleY: this.scaleY,\n      skewX: this.skewX,\n      skewY: this.skewY,\n      strokeLineCap: this.strokeLineCap,\n      strokeLineJoin: this.strokeLineJoin,\n      strokeMiterLimit: this.strokeMiterLimit,\n      strokeUniform: this.strokeUniform,\n      strokeWidth: this.strokeWidth,\n      ...(options || {}),\n    };\n    const points = this.exactBoundingBox\n      ? this._projectStrokeOnPoints(\n          options as TProjectStrokeOnPointsOptions\n        ).map((projection) => projection.projectedPoint)\n      : this.points;\n    if (points.length === 0) {\n      return {\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        pathOffset: new Point(),\n        strokeOffset: new Point(),\n        strokeDiff: new Point(),\n      };\n    }\n    const bbox = makeBoundingBoxFromPoints(points),\n      // Remove scale effect, since it's applied after\n      matrix = calcDimensionsMatrix({ ...options, scaleX: 1, scaleY: 1 }),\n      bboxNoStroke = makeBoundingBoxFromPoints(\n        this.points.map((p) => transformPoint(p, matrix, true))\n      ),\n      scale = new Point(this.scaleX, this.scaleY);\n    let offsetX = bbox.left + bbox.width / 2,\n      offsetY = bbox.top + bbox.height / 2;\n    if (this.exactBoundingBox) {\n      offsetX = offsetX - offsetY * Math.tan(degreesToRadians(this.skewX));\n      // Order of those assignments is important.\n      // offsetY relies on offsetX being already changed by the line above\n      offsetY = offsetY - offsetX * Math.tan(degreesToRadians(this.skewY));\n    }\n\n    return {\n      ...bbox,\n      pathOffset: new Point(offsetX, offsetY),\n      strokeOffset: new Point(bboxNoStroke.left, bboxNoStroke.top)\n        .subtract(new Point(bbox.left, bbox.top))\n        .multiply(scale),\n      strokeDiff: new Point(bbox.width, bbox.height)\n        .subtract(new Point(bboxNoStroke.width, bboxNoStroke.height))\n        .multiply(scale),\n    };\n  }\n\n  /**\n   * This function is an helper for svg import. it returns the center of the object in the svg\n   * untransformed coordinates, by look at the polyline/polygon points.\n   * @private\n   * @return {Point} center point from element coordinates\n   */\n  _findCenterFromElement(): Point {\n    const bbox = makeBoundingBoxFromPoints(this.points);\n    return new Point(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);\n  }\n\n  setDimensions() {\n    this.setBoundingBox();\n  }\n\n  setBoundingBox(adjustPosition?: boolean) {\n    const { left, top, width, height, pathOffset, strokeOffset, strokeDiff } =\n      this._calcDimensions();\n    this.set({ width, height, pathOffset, strokeOffset, strokeDiff });\n    adjustPosition &&\n      this.setPositionByOrigin(\n        new Point(left + width / 2, top + height / 2),\n        CENTER,\n        CENTER\n      );\n  }\n\n  /**\n   * @deprecated intermidiate method to be removed, do not use\n   */\n  protected isStrokeAccountedForInDimensions() {\n    return this.exactBoundingBox;\n  }\n\n  /**\n   * @override stroke is taken in account in size\n   */\n  _getNonTransformedDimensions() {\n    return this.exactBoundingBox\n      ? // TODO: fix this\n        new Point(this.width, this.height)\n      : super._getNonTransformedDimensions();\n  }\n\n  /**\n   * @override stroke and skewing are taken into account when projecting stroke on points,\n   * therefore we don't want the default calculation to account for skewing as well.\n   * Though it is possible to pass `width` and `height` in `options`, doing so is very strange, use with discretion.\n   *\n   * @private\n   */\n  _getTransformedDimensions(options: any = {}) {\n    if (this.exactBoundingBox) {\n      let size: Point;\n      /* When `strokeUniform = true`, any changes to the properties require recalculating the `width` and `height` because\n        the stroke projections are affected.\n        When `strokeUniform = false`, we don't need to recalculate for scale transformations, as the effect of scale on\n        projections follows a linear function (e.g. scaleX of 2 just multiply width by 2)*/\n      if (\n        Object.keys(options).some(\n          (key) =>\n            this.strokeUniform ||\n            (this.constructor as typeof Polyline).layoutProperties.includes(\n              key as keyof TProjectStrokeOnPointsOptions\n            )\n        )\n      ) {\n        const { width, height } = this._calcDimensions(options);\n        size = new Point(options.width ?? width, options.height ?? height);\n      } else {\n        size = new Point(\n          options.width ?? this.width,\n          options.height ?? this.height\n        );\n      }\n      return size.multiply(\n        new Point(options.scaleX || this.scaleX, options.scaleY || this.scaleY)\n      );\n    } else {\n      return super._getTransformedDimensions(options);\n    }\n  }\n\n  /**\n   * Recalculates dimensions when changing skew and scale\n   * @private\n   */\n  _set(key: string, value: any) {\n    const changed = this.initialized && this[key as keyof this] !== value;\n    const output = super._set(key, value);\n    if (\n      this.exactBoundingBox &&\n      changed &&\n      (((key === 'scaleX' || key === 'scaleY') &&\n        this.strokeUniform &&\n        (this.constructor as typeof Polyline).layoutProperties.includes(\n          'strokeUniform'\n        )) ||\n        (this.constructor as typeof Polyline).layoutProperties.includes(\n          key as keyof Polyline\n        ))\n    ) {\n      this.setDimensions();\n    }\n    return output;\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} Object representation of an instance\n   */\n  toObject<\n    T extends Omit<Props & TClassProperties<this>, keyof SProps>,\n    K extends keyof T = never\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SProps {\n    return {\n      ...super.toObject(propertiesToInclude),\n      points: cloneDeep(this.points),\n    };\n  }\n\n  /**\n   * Returns svg representation of an instance\n   * @return {Array} an array of strings with the specific svg representation\n   * of the instance\n   */\n  _toSVG() {\n    const points = [],\n      diffX = this.pathOffset.x,\n      diffY = this.pathOffset.y,\n      NUM_FRACTION_DIGITS = config.NUM_FRACTION_DIGITS;\n\n    for (let i = 0, len = this.points.length; i < len; i++) {\n      points.push(\n        toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS),\n        ',',\n        toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS),\n        ' '\n      );\n    }\n    return [\n      `<${\n        (this.constructor as typeof Polyline).type.toLowerCase() as\n          | 'polyline'\n          | 'polygon'\n      } `,\n      'COMMON_PARTS',\n      `points=\"${points.join('')}\" />\\n`,\n    ];\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   */\n  _render(ctx: CanvasRenderingContext2D) {\n    const len = this.points.length,\n      x = this.pathOffset.x,\n      y = this.pathOffset.y;\n\n    if (!len || isNaN(this.points[len - 1].y)) {\n      // do not draw if no points or odd points\n      // NaN comes from parseFloat of a empty string in parser\n      return;\n    }\n    ctx.beginPath();\n    ctx.moveTo(this.points[0].x - x, this.points[0].y - y);\n    for (let i = 0; i < len; i++) {\n      const point = this.points[i];\n      ctx.lineTo(point.x - x, point.y - y);\n    }\n    !this.isOpen() && ctx.closePath();\n    this._renderPaintInOrder(ctx);\n  }\n\n  /**\n   * Returns complexity of an instance\n   * @return {Number} complexity of this instance\n   */\n  complexity(): number {\n    return this.points.length;\n  }\n\n  /* _FROM_SVG_START_ */\n\n  /**\n   * List of attribute names to account for when parsing SVG element (used by {@link Polyline.fromElement})\n   * @static\n   * @memberOf Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */\n  static ATTRIBUTE_NAMES = [...SHARED_ATTRIBUTES];\n\n  /**\n   * Returns Polyline instance from an SVG element\n   * @static\n   * @memberOf Polyline\n   * @param {HTMLElement} element Element to parser\n   * @param {Object} [options] Options object\n   */\n  static async fromElement(\n    element: HTMLElement,\n    options: Abortable,\n    cssRules?: CSSRules\n  ) {\n    const points = parsePointsAttribute(element.getAttribute('points')),\n      // we omit left and top to instruct the constructor to position the object using the bbox\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      { left, top, ...parsedAttributes } = parseAttributes(\n        element,\n        this.ATTRIBUTE_NAMES,\n        cssRules\n      );\n    return new this(points, {\n      ...parsedAttributes,\n      ...options,\n    });\n  }\n\n  /* _FROM_SVG_END_ */\n\n  /**\n   * Returns Polyline instance from an object representation\n   * @static\n   * @memberOf Polyline\n   * @param {Object} object Object to create an instance from\n   * @returns {Promise<Polyline>}\n   */\n  static fromObject<T extends TOptions<SerializedPolylineProps>>(object: T) {\n    return this._fromObject<Polyline>(object, {\n      extraParam: 'points',\n    });\n  }\n}\n\nclassRegistry.setClass(Polyline);\nclassRegistry.setSVGClass(Polyline);\n"],"names":["polylineDefaultValues","exactBoundingBox","Polyline","FabricObject","getDefaults","_objectSpread","super","ownDefaults","constructor","options","arguments","length","undefined","points","_defineProperty","this","left","top","initialized","setBoundingBox","set","LEFT","TOP","isOpen","_projectStrokeOnPoints","projectStrokeOnPoints","_calcDimensions","scaleX","scaleY","skewX","skewY","strokeLineCap","strokeLineJoin","strokeMiterLimit","strokeUniform","strokeWidth","map","projection","projectedPoint","width","height","pathOffset","Point","strokeOffset","strokeDiff","bbox","makeBoundingBoxFromPoints","matrix","calcDimensionsMatrix","bboxNoStroke","p","transformPoint","scale","offsetX","offsetY","Math","tan","degreesToRadians","subtract","multiply","_findCenterFromElement","setDimensions","adjustPosition","setPositionByOrigin","CENTER","isStrokeAccountedForInDimensions","_getNonTransformedDimensions","_getTransformedDimensions","size","Object","keys","some","key","layoutProperties","includes","_options$width","_options$height","_options$width2","_options$height2","_set","value","changed","output","toObject","propertiesToInclude","cloneDeep","_toSVG","diffX","x","diffY","y","NUM_FRACTION_DIGITS","config","i","len","push","toFixed","concat","type","toLowerCase","join","_render","ctx","isNaN","beginPath","moveTo","point","lineTo","closePath","_renderPaintInOrder","complexity","fromElement","element","cssRules","parsePointsAttribute","getAttribute","_parseAttributes","parseAttributes","ATTRIBUTE_NAMES","parsedAttributes","_objectWithoutProperties","_excluded","fromObject","object","_fromObject","extraParam","cacheProperties","SHARED_ATTRIBUTES","classRegistry","setClass","setSVGClass"],"mappings":"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"}